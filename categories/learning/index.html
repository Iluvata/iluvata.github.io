<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>learning | Iluvata&#39;s Blog</title>

    





<meta name="author" content="Iluvata" />
<meta name="description" content="" />



<meta name="generator" content="Hugo 0.87.0" />

<link rel="canonical" href="https://iluvata.github.io/categories/learning/" />


<meta property="og:title" content="learning" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://iluvata.github.io/categories/learning/" />




<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="learning"/>
<meta name="twitter:description" content=""/>


<link rel="stylesheet" href="/css/semantic.min.css" />
<link rel="stylesheet" href="/css/icomoon.css" />
<link rel="stylesheet" href="/css/OverlayScrollbars.min.css" />
<link rel="stylesheet" href="/css/github-markdown.css" />
<link rel="stylesheet" href="/css/site.css" />

<style>
  a:hover {
    text-decoration: underline; 
  }

  
  a {
    color: seagreen !important;
  }
  

  
  .inverted a,
  .inverted a:hover {
     color: darkseagreen !important;
  }
  

  
  body.default {
    
    background-color: black;
    

    
  }
  

  
</style>

     
  </head>

  <body class="default">
    
<nav class="ui secondary inverted menu dream-menu">

  <div class="item">
    <i class="large link bullseye icon dream-flip-toggle" title="Flip it!"></i>
  </div>
  <div class="item">
    <i class="large link home icon" title="Home" onclick="window.location.href = 'https:\/\/iluvata.github.io'"></i>
  </div>
  <div class="item">
    <i class="large link icon theme-switch" onclick="themeSwitch()"></i>
  </div>
  
</nav>

    <div class="flip-container">
      <div class="flipper">
        <section class="front">
          <div class="dream-max-width">
            
<div class="ui centered relaxed grid dream-grid">
  <div class="sixteen wide mobile eight wide tablet eight wide computer four wide large screen four wide widescreen column dream-column">
    <article class="dream-header">
  <section class="ui top attached center aligned segment">
    <div class="ui small circular image">
      
        <img src="/img/avatar.png">
      
    </div>

    
    <div class="ui medium header">
    
      Iluvata&#39;s blog
      <div class="sub header" style="margin-top: 0.5rem;">shine on you crazy diamond</div>
    
    </div>
    

    <div class="ui horizontal list">
      
      <a class="item" href="/tags">
        <i class="tags icon" title="All Tags"></i>
      </a>
      <a class="item" href="/categories">
        <i class="th list icon" title="All Categories"></i>
      </a>
    </div>
  </section>

  
  <section class="ui attached center aligned segment dream-tags">
    
      
      
      <a class="ui label" href="/tags/algorithm/" title="Algorithm">
        Algorithm
      </a>
    
      
      
      <a class="ui label" href="/tags/ctf/" title="Ctf">
        Ctf
      </a>
    
      
      
      <a class="ui label" href="/tags/emacs/" title="Emacs">
        Emacs
      </a>
    
      
      
      <a class="ui label" href="/tags/hugo/" title="Hugo">
        Hugo
      </a>
    
      
      
      <a class="ui label" href="/tags/information/" title="Information">
        Information
      </a>
    
      
      
      <a class="ui label" href="/tags/math/" title="Math">
        Math
      </a>
    
      
      
      <a class="ui label" href="/tags/operating-system/" title="Operating System">
        Operating System
      </a>
    
      
      
      <a class="ui label" href="/tags/pwn/" title="Pwn">
        Pwn
      </a>
    
      
      
      <a class="ui label" href="/tags/sicp/" title="Sicp">
        Sicp
      </a>
    
      
      
      <a class="ui label" href="/tags/web/" title="Web">
        Web
      </a>
    
      
      
      <a class="ui label" href="/tags/work/" title="Work">
        Work
      </a>
    
      
      
      <a class="ui label" href="/tags/%E8%80%83%E7%A0%94/" title="考研">
        考研
      </a>
    
  </section>
  

  
  <section class="ui attached segment dream-categories">
    <div class="ui accordion">
      
      
      
      
      

      
        

        
          <div class="title">
            <i class="dropdown icon"></i>
            
            
            <a class="item" href="/categories/learning/" title="Learning">
              Learning
            </a>
          </div>
          <div class="content">
            <div class="ui list">
            
              <div class="item">
                <div class="content">
                  <a class="item" href="/post/2021-12-28_hugo-with-latex/">在hugo中使用latex</a>
                </div>
              </div>
            
              <div class="item">
                <div class="content">
                  <a class="item" href="/post/2021-12-28_structural-information/">结构信息论</a>
                </div>
              </div>
            
              <div class="item">
                <div class="content">
                  <a class="item" href="/post/2021-12-28_n1book-web/">N1Book Web 学习</a>
                </div>
              </div>
            
              <div class="item">
                <div class="content">
                  <a class="item" href="/post/2021-12-23_heap/">pwn堆题整理</a>
                </div>
              </div>
            
              <div class="item">
                <div class="content">
                  <a class="item" href="/post/2021-11-13_rop/">ROP</a>
                </div>
              </div>
            
              <div class="item">
                <div class="content">
                  <a class="item" href="/post/2021-11-10_ctf-libc-leak/">libc泄漏</a>
                </div>
              </div>
            
              <div class="item">
                <div class="content">
                  <a class="item" href="/post/2021-09-24_ctf-tools/">CTF基本工具使用指北</a>
                </div>
              </div>
            
              <div class="item">
                <div class="content">
                  <a class="item" href="/post/2021-04-07_iteration-and-recurtion/">迭代与递归</a>
                </div>
              </div>
            
              <div class="item">
                <div class="content">
                  <a class="item" href="/post/2021-03-19_distributions/">概率统计中的分布</a>
                </div>
              </div>
            
              <div class="item">
                <div class="content">
                  <a class="item" href="/post/2021-03-15_computer-structure/">计算机体系结构与组成原理</a>
                </div>
              </div>
            
              <div class="item">
                <div class="content">
                  <a class="item" href="/post/2021-03-14_basic-elements-for-programming-language/">编程语言的基本组成</a>
                </div>
              </div>
            
              <div class="item">
                <div class="content">
                  <a class="item" href="/post/2021-03-09_file-and-database/">文件系统与数据库系统</a>
                </div>
              </div>
            
              <div class="item">
                <div class="content">
                  <a class="item" href="/post/2021-03-04_euler-circuit-and-hamiltonian-circuit/">欧拉环路和汉密尔顿环路</a>
                </div>
              </div>
            
              <div class="item">
                <div class="content">
                  <a class="item" href="/post/2021-03-01_how-computer-startup/">电脑是怎么启动的</a>
                </div>
              </div>
            
              <div class="item">
                <div class="content">
                  <a class="item" href="/post/2021-02-24_greedy-and-dijkstra/">理解贪心算法与Dijkstra算法</a>
                </div>
              </div>
            
              <div class="item">
                <div class="content">
                  <a class="item" href="/post/2021-02-19_dp-and-warshall/">理解动态规划与warshall算法</a>
                </div>
              </div>
            
            </div>
          </div>
        
      
        

        
          <div class="title">
            <i class="dropdown icon"></i>
            
            
            <a class="item" href="/categories/life/" title="Life">
              Life
            </a>
          </div>
          <div class="content">
            <div class="ui list">
            
              <div class="item">
                <div class="content">
                  <a class="item" href="/post/2021-04-19_likehood-reasoning/">最大似然估计与基本演绎法</a>
                </div>
              </div>
            
              <div class="item">
                <div class="content">
                  <a class="item" href="/post/2021-02-22_latex-with-emacs/">在org mode中嵌入latex</a>
                </div>
              </div>
            
              <div class="item">
                <div class="content">
                  <a class="item" href="/post/2021-02-16_yearly-review/">2020年度回顾以及新年目标</a>
                </div>
              </div>
            
              <div class="item">
                <div class="content">
                  <a class="item" href="/post/2021-02-02_scheme-in-emacs/">在spacemacs中写scheme</a>
                </div>
              </div>
            
              <div class="item">
                <div class="content">
                  <a class="item" href="/post/2021-02-02_hugo-with-emacs/">用easy-hugo在spacemacs中写hugo博客</a>
                </div>
              </div>
            
              <div class="item">
                <div class="content">
                  <a class="item" href="/post/2021-01-27_hugo-config/">hugo 博客配置</a>
                </div>
              </div>
            
            </div>
          </div>
        
      

      
    </div>
  </section>
  

  <section class="ui attached segment header-socials">
    <nav class="ui secondary menu dream-menu dream-socials">
  
  
    <div class="item">
      <a href="mailto:dyhdjyc@gmail.com">
        <i class=" mail icon" title="Email"></i>
      </a>
    </div>
  

  

  

  

  

  

  

  

  
</nav>

  </section>

  <section class="ui bottom attached center aligned segment">
    
      <p>© 2021 Iluvata&#39;s Blog</p>
    

    <p>Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a> with theme <a href="https://github.com/g1eny0ung/hugo-theme-dream" target="_blank">Dream</a>.</p>

    
  </section>
</article>

  </div>

  
  
    <div class="sixteen wide mobile eight wide tablet eight wide computer four wide large screen four wide widescreen column dream-column">
      <article class="ui attached segment card dream-card">
  <a class="image" href="https://iluvata.github.io/post/2021-12-28_hugo-with-latex/">
    
      <img src="/img/default1.jpg" alt="在hugo中使用latex" />
    
  </a>

  <div class="content">
    <h2 class="ui medium header">
      <a href="/post/2021-12-28_hugo-with-latex/">在hugo中使用latex</a>
    </h2>
    <div class="meta">
      <p class="date">Tuesday, Dec 28, 2021</p>
    </div>
    <div class="description">
      主要参考这片文章。在katex官网找到Auto-render拓展，在生成的html&lt;head&gt;段中加上以下代码就行了。
&lt;link rel=&#34;stylesheet&#34; href=&#34;https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css&#34; integrity=&#34;sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs&#34; crossorigin=&#34;anonymous&#34;&gt; &lt;script defer src=&#34;https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js&#34; integrity=&#34;sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx&#34; crossorigin=&#34;anonymous&#34;&gt;&lt;/script&gt; &lt;script defer src=&#34;https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js&#34; integrity=&#34;sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR&#34; crossorigin=&#34;anonymous&#34; onload=&#34;renderMathInElement(document.body);&#34;&gt;&lt;/script&gt;   加入的方法为在模板中添加。模板位置为（以我的dream主题为例） /themes/dream/layouts/partials/helpers/katex.html 。但是不要直接照搬上面的代码，最好去网站找最新代码。
 为了能够控制哪些博客需要渲染，而不是渲染所有博客，在 /themes/dream/layouts/partials/head.html 添加以下代码
{{ if .Params.math }}{{ partial &#34;helpers/katex.html&#34; . }}{{ end }}   在需要渲染的博客头上添加
--- math: true ---   如果需要渲染行内表达式，即渲染 $x = {-b \pm \sqrt{b^2-4ac} \over 2a}$ 为 $x = {-b \pm \sqrt{b^2-4ac} \over 2a}$ ，在 katex.html 中写入下面代码
&lt;script&gt; document.addEventListener(&#34;DOMContentLoaded&#34;, function() { renderMathInElement(document.body, { delimiters: [ {left: &#34;$$&#34;, right: &#34;$$&#34;, display: true}, {left: &#34;$&#34;, right: &#34;$&#34;, display: false} ] }); }); &lt;/script&gt;   最后放一个跨行公式测试效果
    </div>
  </div>

  <div class="extra content">
    <div class="author">@&nbsp;Iluvata</div>
    <div class="reading-time">
      <i class="clock icon"></i>1 minutes read</div>
  </div>
</article>

    </div>
  
    <div class="sixteen wide mobile eight wide tablet eight wide computer four wide large screen four wide widescreen column dream-column">
      <article class="ui attached segment card dream-card">
  <a class="image" href="https://iluvata.github.io/post/2021-12-28_structural-information/">
    
      <img src="/img/default4.jpg" alt="结构信息论" />
    
  </a>

  <div class="content">
    <h2 class="ui medium header">
      <a href="/post/2021-12-28_structural-information/">结构信息论</a>
    </h2>
    <div class="meta">
      <p class="date">Tuesday, Dec 28, 2021</p>
    </div>
    <div class="description">
        给定一个分布，想要描述一个服从该分布的随机变量取值平均所需的信息量就是该分布的熵，也可以理解为该分布的不确定性。信息熵越大，该分布的不确定性越大，完全确定取值所需的信息就越多。例如在一个随机变量有8种等可能取值的分布中，为了确定一个结果，需要一个能够容纳8个不同值的标识。因此用3bit字符串足够描述这些标识。如果分布是非均匀的，则可以对概率大的取值用较短的描述，这样我们能得到一个平均更短的描述。这个 描述的平均长度 就是该分布的信息熵。我们定义某一分布的信息熵如下：
  直观地解释， $l=-logp_i$ 是描述概率为 $p_i$ 的事件的二进制长度，熵就是每个事件的描述长度的加权平均。
位置熵/一维结构熵  我们把一张图 $G$ 的度分布的熵叫做图 $G$ 的位置熵，也是图的一维结构熵。
 $$ \begin{aligned} \mathcal{H}^{1}(G) &amp;=H(\mathbf{p})=H\left(\frac{d_{1}}{2 m}, \ldots, \frac{d_{n}}{2 m}\right) \\ &amp;=-\sum_{i=1}^{n} \frac{d_{i}}{2 m} \cdot \log _{2} \frac{d_{i}}{2 m} \end{aligned} $$
 其中 $m$ 为图 $G = (V, E)$ 中边的数量，即 $|E|$ ； $d_i$ 为结点 $i$ 的度。一维结构熵 $H^i(G)$ ，从直观上解释，是确定在有静态分布的图 $G$ 中随机游走能够达到的结点的一维编码所需的信息量。
 现在让我们进一步理解上面这个公式。我们之前对的香农熵解释是：对分布中的每个取值，根据该取值出现的概率给他一个码字（编码）长度，使得描述分布中取值所需的平均编码长度最小。这个最小的编码长度就是分布的信息熵。在位置熵中，我们可以认为简单图中一个结点在随机游走中被访问的概率就是该结点的度在所有结点的度之和中所占的比例。因此若要给该结点一个编码，最优的编码长度应当是 $-\log_2\frac{d_i}{2m}$ 。加权平均后记为该图 $G$ 的位置熵/一维结构熵 $H^1(G)$ 。
  高维结构熵   结构熵最小化   
    </div>
  </div>

  <div class="extra content">
    <div class="author">@&nbsp;Iluvata</div>
    <div class="reading-time">
      <i class="clock icon"></i>1 minutes read</div>
  </div>
</article>

    </div>
  
    <div class="sixteen wide mobile eight wide tablet eight wide computer four wide large screen four wide widescreen column dream-column">
      <article class="ui attached segment card dream-card">
  <a class="image" href="https://iluvata.github.io/post/2021-12-28_n1book-web/">
    
      <img src="/img/default3.jpg" alt="N1Book Web 学习" />
    
  </a>

  <div class="content">
    <h2 class="ui medium header">
      <a href="/post/2021-12-28_n1book-web/">N1Book Web 学习</a>
    </h2>
    <div class="meta">
      <p class="date">Tuesday, Dec 28, 2021</p>
    </div>
    <div class="description">
      buuctf n1book web刷题
信息收集  常见的收集  网站上可能会有敏感目录/文件导致信息泄漏，如.git，vim的备份文件.swp等。可以用dirsearch扫描站点目录。
cd dirsearch python3 dirsearch.py -u 192.168.21.128 -e php    -u 指定目标ip
  -e 指定网站语言
  -w 可以加上自己的字典（带上路径）
  –random-agents 使用代理（使用的代理目录在uesr-agents.txt中，可以自己添加）
  脚本扫描的数据库在 db 文件夹，可以自己加。这题的目标文件有三个： robots.txt , index.php~ , .index.php.swp 。我一开始扫了2次没扫出来，指定了php语言后扫出了robots.txt。
 robots.txt是网站定的允许爬虫规则；后缀为~的是gedit的备份文件；.文件名.swp是vim的备份文件。
  粗心的小李  git泄漏题可以用的工具有GitHack，scrabble。只要目标网站上有.git，运行脚本就能把网站dump下来。
GitHack.py http://www.openssl.org/.git/  scrabble http://example.com/      SQL注入    数字型注入 若输入参数为1，查询的语句为 select * from table where id=1 。若输入参数为1+1返回2的结果，基本能确定是数字型输入。 参数前后没有过滤也没有引号，可以直接union。
    </div>
  </div>

  <div class="extra content">
    <div class="author">@&nbsp;Iluvata</div>
    <div class="reading-time">
      <i class="clock icon"></i>1 minutes read</div>
  </div>
</article>

    </div>
  
    <div class="sixteen wide mobile eight wide tablet eight wide computer four wide large screen four wide widescreen column dream-column">
      <article class="ui attached segment card dream-card">
  <a class="image" href="https://iluvata.github.io/post/2021-12-23_heap/">
    
      <img src="/img/default4.jpg" alt="pwn堆题整理" />
    
  </a>

  <div class="content">
    <h2 class="ui medium header">
      <a href="/post/2021-12-23_heap/">pwn堆题整理</a>
    </h2>
    <div class="meta">
      <p class="date">Thursday, Dec 23, 2021</p>
    </div>
    <div class="description">
      堆溢出  Nnote  花了一周打的UNCTF，光做PWN了，做了7道，就差这道堆题没做出来。最后还有30名以内。。。因为这比赛本身就是入门级的，算是我第一次实战吧。赛后看着wp调试出来。当时应该是找到了漏洞点，但因为基础薄弱最终也没做出来，更别说环境还弄了半天没弄好。。。通过这道题我算是实际开始入门堆了吧。这里是官方wp。
exp环境  题目给的libc是2.31
patchelf --set-rpath ~/glibc-all-in-one/libs/2.31 ./Nnote patchelf --set-interpreter ~/glibc-all-in-one/libs/2.31/ld-2.31.so ./Nnote    泄漏libc  从libc-2.26开始加入了TCache，2.28加入对TCache二次释放的检查. TCache为每个线程加入64个单链表的bins，（64bit系统）以16字节递增，从24B到1032B。每个bins最多放7个chunk。堆开头的0x250的堆块就是tcache_perthread_struct. 在free时，如果chunk大小符合要求，就会在放入fastbins之前放入tcache。分配堆块时若从fastbins中成功返回一个chunk，对应fastbins中其他chunk会被放入对应tcache直到装满。small bins中情况类似。chunk合并时chunk会优先放入tcache。tcache中chunk的PREV_INUSE位和在fastbins中一样不会被清零，因此不会被合并。
 因此这题需要先构造出大于0x410(1040B)的堆块，释放进unsorted bin。需要注意在想释放的堆块后还要再申请一块chunk，防止因为和topchunk相邻而直接合并进topchunk。unsorted bin中如果只有一个chunk，并且这个chunk在上次分配时被使用过时，若申请一个大小属于small bins(32B-1008B)的空间，会直接从该chunk中进行切割，切出低地址部分返回。
 这题申请大小限制不小于0，不大于128，并且根据申请的大小限制了修改时能写入的字节数。但是申请0B的堆块时能通过整数溢出绕过限制条件引起堆溢出。因此这里构造大小为0x480的chunk的方法就是构造9个连在一起的，大小为0x80的chunk（malloc申请的大小为0x78）；然后利用最上面堆块上面的堆溢出覆盖第一块的块大小字段为0x481（块大小字段最低bit为PREV_INUSE）。释放后再申请一个0x80的chunk，会从之前释放到unsorted bin头部割出0x80，导致现在在unsorted bin中的chunk和原来申请的9块中的第二块重叠，输出第二块的数据就可以得到unsorted bin。
add(0) for i in range(9): add(0x78) add(0x18) edit(0 , &#39;a&#39;*0x18+p64(0x481)) delete(1) add(0x78) show(2) __malloc_hook = l64() - 0x70 libc.address = __malloc_hook - libc.sym[&#39;__malloc_hook&#39;]   得到的地址和main_arena(或__malloc_hook)之间的偏移是固定的。可以在gdb调试里看到与__malloc_hook之间的偏移为0x70。
gef➤ bins tcachebins empty fastbins 0x20: 0x0 0x30: 0x0 0x40: 0x0 0x50: 0x0 0x60: 0x0 0x70: 0x0 0x80: 0x0 unsortedbin all: 0x558be3001330 —▸ 0x7f6c92886be0 (main_arena+96) ◂— 0x558be3001330 smallbins empty largebins empty gef➤ x/gx &amp;__malloc_hook 0x7f6c92886b70 &lt;__malloc_hook&gt;:	0x0000000000000000    劫持free_hook  这时候申请两个0x40的chunk，序号分别为11和12.
    </div>
  </div>

  <div class="extra content">
    <div class="author">@&nbsp;Iluvata</div>
    <div class="reading-time">
      <i class="clock icon"></i>1 minutes read</div>
  </div>
</article>

    </div>
  
    <div class="sixteen wide mobile eight wide tablet eight wide computer four wide large screen four wide widescreen column dream-column">
      <article class="ui attached segment card dream-card">
  <a class="image" href="https://iluvata.github.io/post/2021-11-13_rop/">
    
      <img src="/img/default4.jpg" alt="ROP" />
    
  </a>

  <div class="content">
    <h2 class="ui medium header">
      <a href="/post/2021-11-13_rop/">ROP</a>
    </h2>
    <div class="meta">
      <p class="date">Saturday, Nov 13, 2021</p>
    </div>
    <div class="description">
       BROP  确定retaddr的偏移   寻找stopgadget  可以用io.recv()是否成功来判断是否为stopdadget，并且可以根据返回的内容大致猜测覆盖的地址是什么函数
  寻找bropgadget  所谓bropgadget其实就是__libc_csu_init里最后一段包含6个连续pop的汇编，对这段汇编进行偏移还能构造出对于另外几个寄存器的pop。 寻找方法也就是在猜测的retaddr后跟6个trap（会导致程序崩溃的retaddr），再跟上之前找到的stopgadget，最后再跟几个trap。验证的方法可以是在跟上6个trap后不跟stopgadget而是直接跟上trap，看是否会崩溃（如果不会崩溃，有可能是遇到了plt表。为什么plt表不会崩溃？因为plt表用jmp直接跳转去执行函数了）。
  寻找puts/write@plt  通过尝试puts出elf头的\x7fELF确定是否遇到了puts的plt
  dump出内存  用之前得到的puts@pltdump出内存
  在dump出的内存中找到任意函数的got，打印出got内容从而确定libc和偏移   ret2libc     SROP   
    </div>
  </div>

  <div class="extra content">
    <div class="author">@&nbsp;Iluvata</div>
    <div class="reading-time">
      <i class="clock icon"></i>1 minutes read</div>
  </div>
</article>

    </div>
  
    <div class="sixteen wide mobile eight wide tablet eight wide computer four wide large screen four wide widescreen column dream-column">
      <article class="ui attached segment card dream-card">
  <a class="image" href="https://iluvata.github.io/post/2021-11-10_ctf-libc-leak/">
    
      <img src="/img/default3.jpg" alt="libc泄漏" />
    
  </a>

  <div class="content">
    <h2 class="ui medium header">
      <a href="/post/2021-11-10_ctf-libc-leak/">libc泄漏</a>
    </h2>
    <div class="meta">
      <p class="date">Wednesday, Nov 10, 2021</p>
    </div>
    <div class="description">
      libc泄漏在pwn题里很常见，在这里整理一下常见的泄漏libc的方法。 ROP中的ret2libc需要知道libc的版本和偏移，需要泄漏内存中函数的地址。 fmtstr中有时需要知道libc的偏移后用system函数覆盖某些函数的got。 堆利用中也会有用system覆盖函数got的利用方式。
常见泄漏方法  未知libc版本时  常用的泄漏方法有泄漏某个函数的got内容，根据泄漏的地址用LibcSearcher搜索libc。函数的got地址可以用ELF在目标二进制文件中搜到。 在可以泄漏任意地址内容的时候可以用DynELF。
    格式化字符串漏洞  NJCTF2017 pingme  这题是blind fmt，只提供了ip和端口。在从内存dump下代码后搜索到printf@got，泄漏出printf地址。用泄漏的printf地址搜索libc-database得到libc版本后在libc中搜到system，用system和printf的相对地址转化得到system在进程中的地址。然后利用fmtstring用system覆盖printf@got。 如果libc-database搜不到，可以用DynELF来泄漏system地址。
def leak(addr): p = remote(&#39;127.0.0.1&#39;, &#39;10001&#39;) p.recvline() payload = &#34;%9$s.AAA&#34; + p32(addr) p.sendline(payload) data = p.recvuntil(&#34;.AAA&#34;)[:-4] + &#34;\x00&#34; log.info(&#34;leaking: 0x%x--&gt; %s&#34; % (addr, data.encode(&#39;hex&#39;))) p.close() return data data = DynELF(leak, 0x08048490) # Entry point address system_addr = data.lookup(&#39;system&#39;, &#39;libc&#39;) printf_addr = data.lookup(&#39;printf&#39;, &#39;libc&#39;) log.info(&#34;system address: 0x%x&#34; % system_addr) log.
    </div>
  </div>

  <div class="extra content">
    <div class="author">@&nbsp;Iluvata</div>
    <div class="reading-time">
      <i class="clock icon"></i>1 minutes read</div>
  </div>
</article>

    </div>
  
    <div class="sixteen wide mobile eight wide tablet eight wide computer four wide large screen four wide widescreen column dream-column">
      <article class="ui attached segment card dream-card">
  <a class="image" href="https://iluvata.github.io/post/2021-09-24_ctf-tools/">
    
      <img src="/img/default2.jpg" alt="CTF基本工具使用指北" />
    
  </a>

  <div class="content">
    <h2 class="ui medium header">
      <a href="/post/2021-09-24_ctf-tools/">CTF基本工具使用指北</a>
    </h2>
    <div class="meta">
      <p class="date">Friday, Sep 24, 2021</p>
    </div>
    <div class="description">
      环境搭建  在mac上我觉得比较好用的环境是multipass中ubuntu虚拟机+宿主机中的idapro，以及宿主机上vscode写python wp，在虚拟机中运行。
 multipass默认分配的内存和磁盘不太够用，建议内存分4G，磁盘分15G。ubuntu版本选择16.04. 虚拟机内环境配置可以参考pwn-env-init，建议使用py2. 但是脚本是用apt-get安装pip的，可能会有些问题，需要 curl https://bootstrap.pypa.io/pip/2.7/get-pip.py --output get-pip.py 然后运行 get-pip.py 。还有 one_gadget 目前需要ruby版本高于2.4，apt-get安装的ruby是2.3。可以执行下面的命令安装
$ sudo apt-add-repository ppa:brightbox/ruby-ng $ sudo apt-get update $ sudo apt-get install ruby2.4 ruby2.4-dev $ ruby2.4 -v   还可以装个 tmux ，在pwntools连接gdb调试的时候在开头加上下面代码就可以分出调试窗口（虽然我现在也还没配好pwntools舒服地连gdb的环境。。。）。
context.arch=&#34;amd64&#34; context.terminal = [&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;]    pwntools  io交互  连接
本地 ：sh = porcess(&#34;./level0&#34;) 远程：sh = remote(&#34;127.0.0.1&#34;,10001) 关闭连接：sh.close()   io
sh.send(data) 发送数据 sh.sendline(data) 发送一行数据，相当于在数据后面加\n sh.recv(numb = 2048, timeout = dufault) 接受数据，numb指定接收的字节，timeout指定超时 sh.
    </div>
  </div>

  <div class="extra content">
    <div class="author">@&nbsp;Iluvata</div>
    <div class="reading-time">
      <i class="clock icon"></i>3 minutes read</div>
  </div>
</article>

    </div>
  
    <div class="sixteen wide mobile eight wide tablet eight wide computer four wide large screen four wide widescreen column dream-column">
      <article class="ui attached segment card dream-card">
  <a class="image" href="https://iluvata.github.io/post/2021-04-07_iteration-and-recurtion/">
    
      <img src="/img/default4.jpg" alt="迭代与递归" />
    
  </a>

  <div class="content">
    <h2 class="ui medium header">
      <a href="/post/2021-04-07_iteration-and-recurtion/">迭代与递归</a>
    </h2>
    <div class="meta">
      <p class="date">Wednesday, Apr 7, 2021</p>
    </div>
    <div class="description">
      递归处理与递归过程  用一个经典的递归例子：阶乘 来说明。
(define (factorial n) (if (= n 1) 1 (* n factorial (- n 1))))  以上是经典的阶乘的递归处理，若输入为1则输出1,否则结果为当前n×递归执行n-1.
(define (factorial n) (fact-iter 1 1 n)) (define (fact-iter product counter max-count) (if (&gt; counter max-count) product (fact-iter (* counter product) (+ count 1) max-count)))  以上是阶乘的迭代处理。我们在每一次迭代（循环）中输入了得到下一结果所需的所有信息，编译器无需像在递归处理中一样 保存每次n的值以计算最后的结果。
 但是用我们熟悉的c语言来理解以上这段代码，我们会觉得在形式上 fact-iter 函数在函数体中调用了自身，也应该算作 递归而不是迭代。在c语言中，我们理解的迭代是使用 for 或 while 在代码块中显式地更改变量，以上代码很明显 没有使用“循环”。这就引出了递归过程与递归处理的区别。以上代码使用的确实是我们在c语言中称作“递归过程”的代码形式， 但根据我们对“迭代处理”的定义，即编译器无需保存中间变量，它很显然是符合“迭代处理”要求的。在c语言和其他很多 语言中，使用递归过程的迭代处理会和普通的递归处理一样，在每次递归中保存一些值，导致无法到达很深的递归深度。在lisp 编译器的实现中使用了“尾递归”优化技术，即若一个函数在调用自身时（满足递归过程条件）将该调用放在最后执行，并且 无需保存多余的变量，将所有必要的变量输入下一层，那么编译器在执行的时候就不会保存多余的信息，而是像迭代那样直接 用下一层来覆盖当前层。
  多种形式的递归与迭代  线性递归  上面factorial的递归实现中每次进入一个下一层，保存的数据随n的增大是线性增长的。这种形式的递归处理叫做线性递归。
    </div>
  </div>

  <div class="extra content">
    <div class="author">@&nbsp;Iluvata</div>
    <div class="reading-time">
      <i class="clock icon"></i>1 minutes read</div>
  </div>
</article>

    </div>
  
    <div class="sixteen wide mobile eight wide tablet eight wide computer four wide large screen four wide widescreen column dream-column">
      <article class="ui attached segment card dream-card">
  <a class="image" href="https://iluvata.github.io/post/2021-03-19_distributions/">
    
      <img src="/img/default4.jpg" alt="概率统计中的分布" />
    
  </a>

  <div class="content">
    <h2 class="ui medium header">
      <a href="/post/2021-03-19_distributions/">概率统计中的分布</a>
    </h2>
    <div class="meta">
      <p class="date">Friday, Mar 19, 2021</p>
    </div>
    <div class="description">
       连续分布  均匀分布   正态分布  距离某一中心值偏离的误差越大的概率越小。可用于自然界许多现象的模拟.
  指数分布  EX=1/lambda DX=1/lambda^2 指数分布的无记忆性：先验概率与后验概率相同。可用于模拟电器使用：不管之前使用了多久， 能继续使用x小时的概率不变。 先验概率 后验概率
    离散分布  0-1分布  0-1分布随机变量取值为0或1，参数只有一个p，即取值为1的概率。
  二项分布  二项分布是多个相同0-1分布的叠加。B(n,p)中n为随机变量的数量，p和0-1分布中相同。 输入k得到的结果为k个随机变量得到1的概率。
  泊松分布  EX=DX=lambda 在二项分布数值非常大的时候B(1000, 0.001), n=1000, p=0.001的时候计算量非常大。 可以用泊松分布进行模拟。lambda=n*p, 随机变量为k. 经常被用来模拟排队。在每个离散时间一个客户可能来的概率为p, 泊松分布可以模拟 总客户数为n时在时间点k来的客户数量。
    
    </div>
  </div>

  <div class="extra content">
    <div class="author">@&nbsp;Iluvata</div>
    <div class="reading-time">
      <i class="clock icon"></i>1 minutes read</div>
  </div>
</article>

    </div>
  
    <div class="sixteen wide mobile eight wide tablet eight wide computer four wide large screen four wide widescreen column dream-column">
      <article class="ui attached segment card dream-card">
  <a class="image" href="https://iluvata.github.io/post/2021-03-15_computer-structure/">
    
      <img src="/img/2021-03-15_A-Simplified-MIPS-Processor-Architecture.png" alt="计算机体系结构与组成原理" />
    
  </a>

  <div class="content">
    <h2 class="ui medium header">
      <a href="/post/2021-03-15_computer-structure/">计算机体系结构与组成原理</a>
    </h2>
    <div class="meta">
      <p class="date">Monday, Mar 15, 2021</p>
    </div>
    <div class="description">
      计算机体系结构概要  计算机体系结构讲的是同系列计算机为操作系统提供的接口（包括机器语言、汇编语言等），以及底层 硬件的结构设计。计算机组成原理讲的是硬件实现。目前的计算机一般都是用冯诺依曼结构，特点是 存储程序，即将程序作为数据和数据存储在同一存储器中。要执行程序的时候从第一个存储单元开始 顺序执行，根据控制流跳转。与之对应的是哈佛结构，将数据和程序分别存放在两个不同的存储器 中。
 要了解计算机，首要的是了解计算机是怎么存储数据的。包括补码、原码等各种格式和他们的运算。 在了解了数据在计算机中的表示方式后，我们需要知道他们在哪里如何被存储，在哪里怎么进行运算。 在了解计算机进行运算的步骤之前需要知道计算机是用什么格式发出命令的，即机器语言与汇编语言。 以上便是计算机主机的任务：存储、运算、控制。除此之外，计算机还需要规范数据如何在各部件间 传输，即确定总线的相关标准。最后，如果只有之前的操作我们只能将计算机看作一个黑盒，什么都 进不去，什么都出不来，就算一直在计算也没有用处。因此对于输入/输出的讨论也极为重要。
  现代计算机中，控制器和运算器一起被叫做CPU，CPU和主存一起组成主机，主机与外设一起组成硬件设备。 硬件和软件一起组成计算机系统。
  存储器层次结构  目前我们能用于做存储器的材料与工艺有很多，不同方式/目的做出的存储器特性也不同。如磁盘，磁带， RAM，ROM，FLASH等。存储器的分类方式有很多，如用用掉电后能否保存数据可以分成挥发性存储器与 非挥发性存储器；能否随机访问可以分为随机访问存储器与顺序访问存储器等。除此之外，就算是在 主机内部使用的存储器，不同工艺也有很大的性能与价格差距。SRAM可以用于寄存器，速度最快， 但是集成度低，在单位空间内塞不下很大容量，并且价格贵。DRAM动态随机访问存储器一般用于主存， 相比SRAM速度较慢，但是集成度较高并且便宜。
 我们对计算机性能的要求是无上限的，但同时成本也需要控制在可接受的范围。因此就算我们让一台计算机 主机内所有的存储器都用SRAM，我们还是会想要更大更快的内存。为了解决上述价格与速度的矛盾，我们 引入了分层次存储器。在拥有DRAM作为主存的大容量低价格的同时使用SRAM作为CPU内部寄存器以获取高速度。 完整的层次结构中速度从快到慢，容量从小到大是：寄存器-cache-主存-外存.
 主存与CPU之间通过总线相连，数据从主存中取出到寄存器中，在寄存器中传入ALU等部件组成的数据通路进行 计算，得到的结果也存放在寄存器，需要时写入主存中。随着硬件的发展，虽然主存的速度也在不断增长， 但CPU速度的增长速度远大于主存，两者之间的速度差距越来越大。为了调节两者间的速度差异，最大 程度发挥CPU性能，Cache作为高速缓存被引入。Cache具有接近CPU的存取速度，保存最近常用的主存中 的单元副本，并且实时更新。主存、Cache、CPU之间的关系，乃至整个存储器层次结构中上下层软硬件 的关系，我们可以形象的用柜台和仓库进行类比。存取速度更快但是容量更小的上层存储器是商店里的柜台， 下层存储器是商店的仓库，数据是仓库中的物品。当用户/计算机需要购买物品时，如果柜台中有物品 就可以直接从柜台快速拿取，若没有则需要经过繁琐的步骤去仓库取出。但是我们不能把仓库中所有物品 直接放入柜台。还有一种类比是把数据看作学生使用的文具，最上层，即速度最快，容量最小的一层是 学生书桌上的文具盒，需要的时候可以随时取用。下一层是书包，可能有些较大的文具无法放在文具盒中， 这时就需要花稍多的时间从背包内取出。再下一层可以是学生的家。有时候可能会把要用的东西落在了家中， 或者书包也装不下，只能放在家中。这时若再需要用到就要花大代价跑回家去拿。但是一旦从家中拿到了 文具，已经将它装在了包里，那下次再次取用就只要去包里找就行了。CPU内寄存器、Cache、主存间的关系 大致是这样，只是这里的“物品”：数据是可以被拷贝到上层存储器的，从下层“取走”到上层后下层还保留着 一份原本，上层只是“复制”走了一份副本。值得一提的一点是为什么我们每天只需要一个包来装学习用品 就够日常使用了，而不是经常跑回家拿东西呢？假设我们把所有科目的书和试卷等全都放在家里，每天的 课程表让我们知道当天的科目，再加上当前的课程进度，综合起来我们可以判断只需要带走一部分相关的资料 而非全部科目的所有资料就足够当天的学习使用了。在计算机中也有类似的情况，就是计算机在执行一道 程序的时候在一段时间内会反复使用同一段或相邻的空间。这就相当于得知了当前的“课程进度”和“课表” 后，我们能够确定大致需要带的资料，在一段时间（比如一天）内无需反复回家更换。程序在一段时间 内反复访问相同的空间的特性叫做时间局部性，访问某空间后大概率访问相邻空间的特性叫做空间局部性。 程序的局部性原理使得是的Cache能够作为CPU与主存间的高速缓存大大提升整体系统的效率。
 那么我们在使用Cache的时候需要注意哪些细节呢？首先，由于一个学生在上学的时候不可能把整个家里所有 东西都装在背包中，需要挑选出每天要带走的东西。Cache需要确定保存哪些副本，当空间满了的时候 如何进行替换。Cache的替换策略有随机替换, FIFO, LRU, LFU. 其次，Cache中保存的是主存中的副本， Cache以行为单位，一行内可以包括多个主存单元（一般是1字节大小），与行对应大小的单位在主存 中被称为块。Cache最理想的实现方式是每行都能保存主存中任意块的副本，但是由于Cache的总 容量比主存小，我们需要对存在每行中的每个块指定一个标识以分辨对应主存中的位置。 按照上面的设想，我们需要在每行保存完整的主存块地址（非存储单元地址，用于分辨块中不同存储 单元的最后几位不用记录）作为唯一标识，这样每次想要找出CPU给出的主存单元对应的Cache行所需 的开销就会比较大。那么我们可以换一种思路进行映射：由于主存容量较大，地址的长度也比Cache中地址要长， 那我们把高位多出来的那部分作为唯一标识，剩下的主存地址就直接用到Cache上当作行地址，这样需要保存 的标识长度就短了很多，每次在Cache中找对应的主存块也不用对比所有行的标识，只需找到编号低位 与地址相同的那一行。以上两种Cache与主存之间的映射方式分别是全相联映射和直接映射。有的时候， 我们虽然用不起全相联映射，又发现直接映射太过于死板以至于在跑一些程序的时候无法很好的 完整高速缓存的工作（无法很好利用时间局部性），那就可以将两者结合起来，先将Cache中的行分组， 在组内进行任意对应。这就是组相联映射。
    </div>
  </div>

  <div class="extra content">
    <div class="author">@&nbsp;Iluvata</div>
    <div class="reading-time">
      <i class="clock icon"></i>1 minutes read</div>
  </div>
</article>

    </div>
  

  <div class="sixteen wide mobile eight wide tablet eight wide computer four wide large screen four wide widescreen column dream-column">
    


<article class="ui attached center aligned segment card dream-card">
  <div class="content">
    <div class="ui medium header">
      <a href="/categories/learning/page/2/" title="Next page">
        Next page
      </a>
    </div>
  </div>
</article>


  </div>
</div>

          </div>
        </section>
        <section class="back">
          <div class="dream-max-width">
            <div class="ui centered relaxed grid dream-grid dream-back">
  
  
  

  <section class="sixteen wide mobile eight wide tablet four wide computer column dream-column">
    <article>
      <div class="ui top attached segment">
        <h3 class="ui header">Social Links</h3>
      </div>
      <div class="ui bottom attached segment">
        <nav class="ui secondary menu dream-menu dream-socials">
  
  
    <div class="item">
      <a href="mailto:dyhdjyc@gmail.com">
        <i class="large mail icon" title="Email"></i>
      </a>
    </div>
  

  

  

  

  

  

  

  

  
</nav>

      </div>
    </article>
  </section>

  <section class="sixteen wide mobile eight wide tablet four wide computer column dream-column">
    
  </section>

  
    
  
</div>

          </div>
        </section>
      </div>
    </div>

    <script>
  window.defaultDark =  null 
  window.backgroundDark =  null 
  window.backgroundImageDark =  null 
  window.darkNav =  true 
  window.hasTwitterEmbed =  null 

  if (window.hasTwitterEmbed) {
    
    window.twttr = (function (d, s, id) {
      var js,
        fjs = d.getElementsByTagName(s)[0],
        t = window.twttr || {}
      if (d.getElementById(id)) return t
      js = d.createElement(s)
      js.id = id
      js.src = 'https://platform.twitter.com/widgets.js'
      fjs.parentNode.insertBefore(js, fjs)

      t._e = []
      t.ready = function (f) {
        t._e.push(f)
      }

      return t
    })(document, 'script', 'twitter-wjs')
  }
</script>
<script src="/js/jquery.min.js"></script>
<script src="/js/semantic.min.js"></script>
<script src="/js/jquery.overlayScrollbars.min.js"></script>
<script src="/js/header.js"></script>
<script src="/js/main.js"></script>
<script src="/js/theme.js"></script>

    
<script src="/js/imagesloaded.pkgd.min.js"></script>
<script src="/js/masonry.pkgd.min.js"></script>
<script src="/js/grid.js"></script>


    

    
  </body>
</html>
