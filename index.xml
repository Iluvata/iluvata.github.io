<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Iluvata&#39;s Blog</title>
    <link>https://iluvata.github.io/</link>
    <description>Recent content on Iluvata&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 15 Mar 2021 13:13:42 +0800</lastBuildDate><atom:link href="https://iluvata.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>计算机体系结构与组成原理</title>
      <link>https://iluvata.github.io/post/2021-03-15_computer-structure/</link>
      <pubDate>Mon, 15 Mar 2021 13:13:42 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-03-15_computer-structure/</guid>
      <description> 计算机体系结构概要  计算机体系结构讲的是同系列计算机为操作系统提供的接口（包括机器语言、汇编语言等），以及底层 硬件的结构设计。计算机组成原理讲的是硬件实现。目前的计算机一般都是用冯诺依曼结构，特点是 存储程序，即将程序作为数据和数据存储在同一存储器中。要执行程序的时候从第一个存储单元开始 顺序执行，根据控制流跳转。与之对应的是哈佛结构，将数据和程序分别存放在两个不同的存储器 中。
 要了解计算机，首要的是了解计算机是怎么存储数据的。包括补码、原码等各种格式和他们的运算。 在了解了数据在计算机中的表示方式后，我们需要知道他们在哪里如何被存储，在哪里怎么进行运算。 在了解计算机进行运算的步骤之前需要知道计算机是用什么格式发出命令的，即机器语言与汇编语言。 以上便是计算机主机的任务：存储、运算、控制。除此之外，计算机还需要规范数据如何在各部件间 传输，即确定总线的相关标准。最后，如果只有之前的操作我们只能将计算机看作一个黑盒，什么都 进不去，什么都出不来，就算一直在计算也没有用处。因此对于输入/输出的讨论也极为重要。
  现代计算机中，控制器和运算器一起被叫做CPU，CPU和主存一起组成主机，主机与外设一起组成硬件设备。 硬件和软件一起组成计算机系统。
  存储器层次结构  目前我们能用于做存储器的材料与工艺有很多，不同方式/目的做出的存储器特性也不同。如磁盘，磁带， RAM，ROM，FLASH等。存储器的分类方式有很多，如用用掉电后能否保存数据可以分成挥发性存储器与 非挥发性存储器；能否随机访问可以分为随机访问存储器与顺序访问存储器等。除此之外，就算是在 主机内部使用的存储器，不同工艺也有很大的性能与价格差距。SRAM可以用于寄存器，速度最快， 但是集成度低，在单位空间内塞不下很大容量，并且价格贵。DRAM动态随机访问存储器一般用于主存， 相比SRAM速度较慢，但是集成度较高并且便宜。
 我们对计算机性能的要求是无上限的，但同时成本也需要控制在可接受的范围。因此就算我们让一台计算机 主机内所有的存储器都用SRAM，我们还是会想要更大更快的内存。为了解决上述价格与速度的矛盾，我们 引入了分层次存储器。在拥有DRAM作为主存的大容量低价格的同时使用SRAM作为CPU内部寄存器以获取高速度。 完整的层次结构中速度从快到慢，容量从小到大是：寄存器-cache-主存-外存.
 主存与CPU之间通过总线相连，数据从主存中取出到寄存器中，在寄存器中传入ALU等部件组成的数据通路进行 计算，得到的结果也存放在寄存器，需要时写入主存中。随着硬件的发展，虽然主存的速度也在不断增长， 但CPU速度的增长速度远大于主存，两者之间的速度差距越来越大。
  指令系统/CPU   总线与IO   </description>
    </item>
    
    <item>
      <title>编程语言的基本组成</title>
      <link>https://iluvata.github.io/post/2021-03-14_basic-elements-for-programming-language/</link>
      <pubDate>Sun, 14 Mar 2021 22:50:46 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-03-14_basic-elements-for-programming-language/</guid>
      <description>编程语言的基本组成  编程语言的基本组成是SICP的第一节讨论的内容。编程语言所需要的基本元素有3个：原子元素（原子过程、 原子数据结构）、将运算进行复合的能力、对过程进行抽象的能力。
 原子元素是语言本身提供给我们的最小过程与数据结构，如乘法 * ，整数数据类型. 在scheme中我们将 一个操作过程写在括号语句内，语句的第一个元素作为运用的过程（操作符），随后的元素作为操作数。如
(* 3 4)   运算复合的能力使我们能够从基本操作中构建复杂操作，如求解阶乘
(define (factorial n) (if (&amp;lt; n 2) 1 (* n (factorial (- n 1)))))   最后是构建抽象的能力，能够让我们不被所有实现细节扰乱思路，只把之前构建的函数当作黑盒直接拿来 使用
(factorial 4)    块结构–以牛顿法求平方根为例  牛顿法是用于求解方程根的算法，从一个猜测开始每次迭代得到一个更好的猜测，不断向根逼近，直到 一个我们指定的要求达到为止。 通过使用抽象和运算符合的能力，我们能够构造improve, good-enough?等方法，最终构造出我们想要的 sqrt算法。
(define (sqrt-iter guess x) (if (good-enough? guess x) guess (sqrt-iter (better-guess guess x) x))) (define (sqrt x) (sqrt-iter 2.0 x))  在求解的过程中，我们定义的一些方法只有在sqrt中才会被用到，如improve, good-enough?等。为了 防止和其他代码名称冲突，可以把他们全都放到sqrt的定义内，让他们的作用域只限于sqrt.</description>
    </item>
    
    <item>
      <title>推荐系统的鲁棒性</title>
      <link>https://iluvata.github.io/post/2021-03-11_recommend-system-robustness/</link>
      <pubDate>Thu, 11 Mar 2021 07:43:55 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-03-11_recommend-system-robustness/</guid>
      <description> 推荐系统概述  推荐系统通过建立用户与产品间的二元关系，利用用户已有的选择过程或相似性关系挖掘每个用户 潜在的感兴趣对象，进而进行个性化推荐的系统。根据其推荐原理的不同，大致可以分为
  协同过滤推荐算法
  基于内容的推荐算法
  基于用户-产品二部图关系的推荐算法
  混合推荐算法
  其中协同过滤算法“利用用户已有的选择过程推荐”；基于内容的推荐算法“利用用户或物品间的 相似性关系”；基于用户-产品二部图关系的推荐算法是利用图论的方法进行推荐，类似于PageRank算法。
  推荐系统评价指标  我们一般在评价推荐系统的时候使用的是准确率和召回率。   正确率 = 提取出的正确信息条数 / 提取出的信息条数   召回率 = 提取出的正确信息条数 / 样本中正确的信息条数   准确率给出提取的信息中正确的比例，召回率给出所有正确信息中被提出的比例。除了常用的两个 指标，用于衡量推荐系统的还有以上两者加权调和平均的F指标，平均绝对误差MAE，平均平方误差MSE（用于 给出评分数值的系统）等。在除了准确率之外，我们有时候希望从一些别的方面对推荐系统做出评价， 包括推荐物品的多样性，新鲜性，用户满意度，可解释性，鲁棒性，公平性等。这里主要讨论推荐系统的 鲁棒性，即在受到破坏（如注入虚假的用户访问记录和用户信息，刷好评，数据缺失）的时候正常工作 的能力。
  推荐系统鲁棒性   参考链接： 个性化推荐系统研究 个性化推荐系统评价方法综述 通过伪造共同访问对推荐系统进行攻击 全能的FM模型
  </description>
    </item>
    
    <item>
      <title>文件系统与数据库系统</title>
      <link>https://iluvata.github.io/post/2021-03-09_file-and-database/</link>
      <pubDate>Tue, 09 Mar 2021 11:40:13 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-03-09_file-and-database/</guid>
      <description>数据库系统  数据库系统的组成部分包括数据库、软件、硬件和用户。数据库指的是系统中各种数据，包括目标数据 和描述数据。软件包括DBMS和开发工具等。 我们一般使用的数据库系统都是关系型数据库，这里将谈论的也主要是关系型。NoSQL之类的非关系型 数据库以后有时间可以去了解一下，我目前的理解是非关系型数据库可以支持使用一些更灵活的结构来 进行数据的存储，如json，可以避免数据结构多样性带来的问题。除了目前最常会用的关系型数据库外， 其他数据库结构还有层次模型和网状模型。
 数据库系统的层次结构如下
 软硬件层次
  DBMS管理层次  关系型数据库中的“关系”即我们在离散数学中学过的关系(relation)：多个集合的笛卡尔积的子集。 只是我们在离散数学中讨论的一般是二元关系，只考虑两个集合。在关系型数据库中，我们考虑的范围 变成了n个集合，即数据库一张表中的n个字段。对于讨论n元关系的关系型数据库，我们能够进行的基本 操作有SELECTION, PROJECTION, JOIN. SELECTION与SQL语句中的查找语句一样，从表中找出满足 条件的语句。PROJECTION删除一些字段，只留下（展示）我们需要的字段。JOIN得到两张表的笛卡尔积。
数据库三范式  数据库在设计表结构的时候为了减少冗余，避免在对数据进行操作时产生问题，需要遵循三范式。第一范式： 所有字段存储的都必须是最小的原子字段，不允许像结构体这样的复合结构。第二范式：所有字段必须完全 依赖于主键。如选课表(课程id，学生id，学生姓名，分数）中学生姓名没有完全依赖于主键（课程id，学生id）， 需要新建一个表（学生id，学生姓名）。否则每次存入相同学生id不同课程id的数据时都会存入相同的 学生姓名，增加了不必要的数据存储导致冗余。第三范式：所有非主键字段直接依赖于主键，不能存在传递依赖。 学生表（学生id，学院id，学院电话）中学院电话通过学院id传递依赖于主键学生id，需要拆分出（学院id，学院电话） 表。第三范式还可以用另一种形式表达：非主键间不能有依赖关系。BC范式在第三范式的基础上进一步限制 了主键间也不能有依赖。表（学生id，老师id，课程id）中，每个老师只能教一门课，每门课程可以有多个 老师，每个学生选了一门课后有对应的一名固定老师。表中三个字段都为主键，但是老师和课程之间存在依赖。   数据库事务  在对数据库进行操作的时候，我们希望有一些操作序列不可被分割，要么全部执行，要么不执行，中间没有别的 操作插入。数据库系统提供了把多条作为一个整体进行操作的功能，把这种整体称为事务。事务具有ACID特性： Atomicity原子性，Consistency一致性，Isolation隔离性，Durability持久性。原子性是我们之前说的 要么所有语句全部执行成功，要么全部不执行。一致性是指事务执行前后特定状态保持一致，如转账操作前后的 转账双方的总金额。隔离性是多个并发事务之间不能互相干扰。持久性是事务提交后的改变是持久（永久）的， 不会丢失COMMIT.
 如果我们不考虑事务的隔离性，可能会发生的情况有：
  脏读：事务在提交前的修改被读到
  不可重复读：事务内的几次查询间别的外部语句修改了数据，导致一次事务中相同的读得到不同数据
  虚读（幻读）：一个事务内对数据进行操作时别的外部语句修改了数据，导致对被修改的记录的操作失败
  不可重复读与幻读的区别是不可重复读查询同一数据项，幻读操作一批数据。
 为了提供不同场景对隔离性的需求，对于事务的隔离性定义了4中隔离级别：读未提交(read uncommitted), 读提交(read committed), 可重复读(repeatable read), 序列化(serializable). 序列化可避免脏读、不可重复读、幻读；可重复读可避免 脏读、不可重复读；读提交可避免脏读；读未提交无法保证任何情况。</description>
    </item>
    
    <item>
      <title>欧拉环路和汉密尔顿环路</title>
      <link>https://iluvata.github.io/post/2021-03-04_euler-circuit-and-hamiltonian-circuit/</link>
      <pubDate>Thu, 04 Mar 2021 17:54:59 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-03-04_euler-circuit-and-hamiltonian-circuit/</guid>
      <description>图论中有两种重要的特殊图：欧拉图和汉密尔顿图，各表示能够找到欧拉环路与汉密尔顿环路的图。 欧拉环路是由七桥问题来的：如何走过7座桥回到起点。在一般的图中，该问题可以被表示为：能不能找到 一条经过所有边，最后回到源点的环路。
 欧拉路径是比欧拉环路更广的概念。欧拉路径即图中经过所有边一次的简单路径，不要求终点和源点为 同一点。汉密尔顿路径与之类似，只是要求的不是经过所有边一次而是经过所有点一次。汉密尔顿环路 即起点与终点在同一点的汉密尔顿路径，汉密尔顿图即能找出汉密尔顿路径的图。
 对于欧拉图的判定最早由欧拉提出。方法很简单：图中每个点的度必须为偶数。判断欧拉路径的方法是 除了两个点外每个点的度数都为偶数，那两个点的度都为奇数。我们可以想象边经过一点的过程，如果 想要经过每条边一次，那每次入射一点后必定需要从另一条新的边出去。就像在一根线上串珠子的过程。 对于欧拉路径，除了头和尾两个点的度为奇数，其他都是偶数。对于欧拉环路来说头和尾是同一点， 从该点射出的路径最终还是要通过另一边回到该点。因此欧拉图所有点的度数都为偶数。
 和欧拉图不同，汉密尔顿图没有已知的多项式时间判定方法。事实上，汉密尔顿图的判定是NP完全问题。 虽然没有找到判断汉密尔顿图的充要条件，但是已知的有充分条件。n&amp;gt;=3个节点的简单图上，任意一对非 邻接节点的度数和&amp;gt;=n.或者，任意节点的度&amp;gt;=n/2.</description>
    </item>
    
    <item>
      <title>电脑是怎么启动的</title>
      <link>https://iluvata.github.io/post/2021-03-01_how-computer-startup/</link>
      <pubDate>Mon, 01 Mar 2021 22:52:59 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-03-01_how-computer-startup/</guid>
      <description>x86启动过程简介  x86计算机开机过程大致可以被分为几个阶段：
  按下开机键
  CPU跳转至BIOS物理地址
  BIOS进行开机自检
  寻找启动设备
  从MBR加载启动区
  BIOS转移控制给BootLoader
  第一阶段：硬件  BIOS  Basic Input/Output System 基本输入输出系统，被固化在ROM上的一组程序，提供最底层对硬件的控制。 也被称为固件。
UEFI  Unified Extensible Firmware Interface 统一可拓展固件接口。堆栈传参，动态链接，更大寻址。
    MBR  Master Boot Record 主引导记录。硬盘的第一个扇区，存放预启动信息、分区表信息。
    第二阶段：系统软件  Boot Loader  操作系统内核加载器。初始化硬件，建立内存空间映射。
  GRUB
  LILO
    加载内核  根据grub设定的内核映像所在路径读取，解压，放入内存。初始化函数，设备，建立Linux核心环境（初始化寄存器、堆栈）。</description>
    </item>
    
    <item>
      <title>理解贪心算法与Dijkstra算法</title>
      <link>https://iluvata.github.io/post/2021-02-24_greedy-and-dijkstra/</link>
      <pubDate>Wed, 24 Feb 2021 10:52:06 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-02-24_greedy-and-dijkstra/</guid>
      <description>贪心与动态规划  我们知道动态规划求解的问题需要具有   最优子结构   重复子问题   具有最优子结构的问题有时也可以用贪心算法求解。条件是最优解中只包含一个子问题的最优解，而一般的动态规划 最优解包含多个子问题的最优解。比如fib算法，fib(5)需要fib(4)与fib(3)两个子问题的解，无法使用贪心算法。 阶乘算法factorial(5)的递归解只需要使用一个子问题factorial(4)的解，这种情况使用贪心算法，即无需自底向上 记录每一子问题的解，只需记录当前最近一子问题的解用于求解当前解。
 一个更直观的例子是0-1背包问题和部分背包问题。背包问题要求在指定的一些商品中选出能装入背包重量的最大价值的商品 组合。0-1背包问题中的每个商品是一个整体，要么整个装入，要么不装。部分背包问题里的商品类似水或金沙，可以分割后 装入部分。0-1背包问题是典型的动态规划例子，而部分背包则可以用贪心。
 我们容易得到背包问题的最优子结构：要求重量的最优解包含了背包去掉某个物品重量后的最优解。考虑所有物品的最优解中 包含了考虑其中部分物品得到的最优解。对于0-1背包问题，通过以上两个维度我们可以列出状态转移方程：从考虑0个物品开始 依次加入每个物品，重量从0开始递增至所给背包重量；当前重量下考虑了当前加入所有物品能得到的最大价值 = max{(当前最大重量减去 当前物品重量后，不考虑当前物品能得到的最大价值 + 当前物品价值), (同等重量，不考虑当前物品能得到的最大价值),( 考虑了当前物品，最大重量-1时能得到的最大价值)}. 对于部分背包问题，如果还是使用0-1背包的方法来求解，我们会发现这次 要求的重量都是连续的，每次递增的重量无法确定。但是不妨假设我们可以每次递增无穷小的重量，就容易看出每次状态转移时， 能得到最大价值的选择一定是从剩余物品中（价值/重量）比例最大的物品中抽取加入。这样每次求最优解用到的唯一一个最优 子问题就能被确定下来，我们可以直接使用贪心算法，即，永远在剩余物品中选择（价值/重量）比例最大的物品加入，直到包 满。
 另一个例子是活动选择问题。对几个互相竞争的活动进行调度，希望找出一个最大的相互兼容活动集合。给出每个活动的开始时间与持续时长， 我们希望得到一定时间段内所能容纳的最多活动数量（多个活动间不能有重叠时间）。容易找到这个问题的最优子结构：每个活动将整体时间分为 两部分：该活动前的时间与该活动后的时间。在这两段时间内我们都需要最大化执行任务数，两段的任务数之和+1，所得的就是整个时间段的最优 解。找到最优子结构后就不难得到动态规划算法了。我们知道在这个问题的最优解中包含了两个子问题的最优解，即：活动左边时间段最优解与右边时间段 最优解。如果我们进一步观察，可以发现如果我们将选择的当前活动限制为当前时间段后开始并能最早执行完的活动，得到当前最优解所需的子问题 就只剩一个：当前活动后的时间段。可以证明该贪心选择能够得到最优解。通过一个简单的变换，我们将原来需要2个子问题的解变成了只需要1个子问题的解。 这种情况下，我们无需记录所有子问题的解来进行动态规划自底向上求解当前解，只需要记录前一子问题的解，自顶向下求解问题。
 一些能够轻易看出使用动态规划求解的问题，可以思考能不能通过变换求解过程得到贪心策略来进一步优化，给出贪心算法。
  贪心策略的基本内容  使用贪心算法需要的条件有两个：
  贪心选择性质
  最优子结构
  贪心选择性质即上文中我们说的“能找到只包含一个子问题的最优解“。通过适当的变换，一些问题可以找到贪心选择性质，如上文中的活动调度问题。 最优子结构即动态规划中的“由子问题的最优解构成当前问题最优解”的性质。满足这两个条件的问题即可使用贪心算法。但在有些情况下，不能轻易找出 最优子结构，但是问题的确可以使用贪心算法求解。比如PAT-1067.
  Dijkstra算法与Bellman-Ford算法  Dijkstra算法  作为图论中几乎是最有名的算法，Dijkstra算法解决了最短路径问题。从算法思想的角度来说，Dijkstra算法使用了贪心策略。与之相对的是 Bellman-Ford算法。同为计算最短路径的算法，Bellman-Ford算法使用了动态规划的思想，复杂度为O(n^3)。Dijkstra算法在此基础上 进一步限定条件（Bellman-Ford算法可以用来计算带有负权的图，Dijkstra只能用于权值为正数的情况）利用了问题具有贪心选择性质，用贪心策略 将最短路径算法的复杂度进一步减到了O(n^2).</description>
    </item>
    
    <item>
      <title>理解动态规划与warshall算法</title>
      <link>https://iluvata.github.io/post/2021-02-19_dp-and-warshall/</link>
      <pubDate>Fri, 19 Feb 2021 13:35:34 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-02-19_dp-and-warshall/</guid>
      <description>今天刚好在离散里学了用来计算传递闭包的warshall算法，就在这里把离散里计算闭包的算法 和动态规划一起整理一下。
集合、关系和闭包  要理解闭包首先需要了解集合和关系（函数）。 在离散数学中我们讨论的集合都是非公理化的朴素集合论（会导致罗素悖论）。有时间可以了解下公理集合论。
关系与函数  关系： 关系是一个集合中的元素到另一个集合中元素的映射方式。二元关系是两个集合笛卡尔积的子集。 关系能够具有的性质包括自反性，对称性，传递性，反自反性，反对称性。具有自反、堆成、传递性 的关系称为等价关系。其他的特殊关系有偏序（包含全序、良序、字典序）
 函数：函数可以看作一种特殊的关系。 函数是每个定义域中元素到唯一一个值域中元素的映射.
 A function from A to B is an assignment of exactly one element of B to each element of A.
 函数的种类包括
  单射 一一对应(one-to-one)函数：如果定义域中的两个元素不相等，那值域中对应的两个元素也肯定不相等.
  满射（onto）函数：值域中每个值都有对应的定义域元素.
  双射： 满足单射及满射
    闭包  闭包：一个集合具有某个性质的最小超集。例如在一个集合S上关系R的自反闭包是R并S0, S0是集合S中所有元素到自身关系的集合。 其他常用的闭包还有对称闭包和传递闭包。自反闭包记作r(R),对称闭包s(R),传递闭包t(R).
 一个关系的自反闭包与对称闭包计算都很简单，传递闭包要麻烦些。一个具有传递性的关系是指在该关系中， 如果出现了(a,b)和(b,c)，则(a,c)也存在。想得到一个关系具有传递性的最小超集，我们要检查当前该关系中所有满足(a,b) (b,c) 的pair，得到(a,c)后加入。但是只进行一次后不一定能得到我们想要的传递性关系。比如原先关系R为{(a,b), (b,c), (c,d)}, 进行一次计算后得到的R1是{(a,b), (b,c), (c,d), (a,c), (b,d)}。R1中存在(a,b)和(b,d)，但是没有(a,d)，并不是我们想要的 自反闭包。我们需要再做一次相同的步骤。在一个无穷关系中，相同的步骤需要执行无穷次。这就是计算传递闭包的算法。</description>
    </item>
    
    <item>
      <title>nextcloud网盘搭建</title>
      <link>https://iluvata.github.io/post/2021-02-19_deploy-nextcloud/</link>
      <pubDate>Fri, 19 Feb 2021 11:45:28 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-02-19_deploy-nextcloud/</guid>
      <description>最近发现在多个设备，系统之间换来换去，文件传输是个问题。想到还有个空闲着的服务器， 为什么不搭个nextcloud网盘，这样在各个系统做笔记和传文件都方便。
 其实我之前在服务器上用过nextcloud，但不知道什么原因好像挂了。。那今天就重新来部署一次吧。
 在网上找到一篇简易的搭建教程,搭建宝塔面板建站，下载nextcloud安装器（php文件，放在网站上浏览器直接访问）， 跟着步骤就安装完成了。。 https://zhuanlan.zhihu.com/p/38485411</description>
    </item>
    
    <item>
      <title>2020年度回顾以及新年目标</title>
      <link>https://iluvata.github.io/post/2021-02-16_yearly-review/</link>
      <pubDate>Tue, 16 Feb 2021 19:00:39 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-02-16_yearly-review/</guid>
      <description> 2020简要回顾  今天是农历大年初五，是个对过去一年进行复盘与新的一年进行规划的好时机。我的过去一年如果用两个词来总结的话应该就是疫情和考研了。由于疫情，前半年我是在家里度过的；后半年到了学校后也是一直在准备考研。
 年初（可能年前就开始了）的时候，由于在家无聊，我开始疯狂追番，然后好像一直看到5月。。。我能记得的那几个月看的番有：碧蓝之海，clannad，青春猪头少年，实教，春物，冰菓，日在校园，笨蛋测验召唤兽，月色真美， 魔法少女小圆，白色相簿2，四谎，k-on 等等。3月开始上网课，4月甚至逃了2周的课从早到晚看小说追完了春物，还在网上买了大老师最喜欢的max咖啡（不得不说还算不错，特别是在5月锻炼完洗了澡后来一罐冰冰的max的感觉贼舒爽）。。
 然后正式开始准备考研应该是在5月中旬，开始的一个月还在看k-on，每天瞎看几个小时数学，然后看几个小时动漫。。
  3月之前还有在一边查考研院校信息一边准备PAT，基本上甲级的题库快刷完了。但最后开学的时间一直在推就把报名退了。代码放在这个仓库。考研一开始选了4个学校：上海科技大学，川大，北航，浙大。最后确定了北航。
 2-3月还开始了英语背单词，于是年后那一两个月的生活就是早上11-12点起床，中午吃了午饭后背背百词斩，下午做个4-5道pat，晚饭后开始看动漫到两三点。 从5月期中考那段时间开始，感觉回校应该无望了，就买了考研书开始准备起来。之后具体的安排写在考研初试里面。8月回校，每天抽点时间准备了大三下的期末考。接着9月学校安排了实训。10月开始可以一心备考，到12月底考完。
 考完后马上在牛客网上投了几份实习简历，回家。十几份简历只有一份网易北京测开的给了面试，然后拿到offer在1月中到北京开始实习。实习到现在也有一个月了，考完初试快2个月了，离复试差不多剩1个月。这期间一边玩一边随便看点 复试有关的东西。是时候开始全力准备复试了。
  考研初试  3-5月   6-7月   8-9月   10-12月     实习  考完后虽然马上投了简历，但其实面试啥的什么都没准备。。岗位也是乱投的，最后感觉应该就安全岗和测开岗比较对我胃口。玩了半个月突然收到电话说明天面试，熬夜找了各种面经，把软件测试课ppt复习了一遍，整理了一份面试资料。 没想到一面没怎么问测试，反倒问了好多编程语言（我说我会的是c++）、面向对象的东西。我基本快忘完了，靠着久远的记忆说出来一些。算法也只让写了一个反转链表。一面完我以为没了，就算能进二面也要等几天，就又开始放松。 没想到当天下午打来电话通知明天早上二面，又开始找资料。。。我整理了一份我的面经。
 之后是拿到了offer，1月14入职。入职后在测试组做测试，每天没多少任务。分来了需求就写写case，执行case，没怎么用到工具和编程。感觉有点水，但好歹干完3个月，并且认真复习复试吧。
  复试准备  说实话虽然对了答案，但是能不能进复试我心里基本上是一点都没底的。根据考完后对的答案，我数学大概120，英语和政治客观题都是扣了大概10分左右，政治可能更多些。专业课估不了分，但我考试时候不清楚的几个点应该都错了，大概至少少了10分。
 数学我一道大题符号错了，我估的是那道小问分扣光。错了一个选择一个填空扣10分。好像还错了一道大题。我觉得最后100-130都有可能（130不太可能吧。。。） 英语作文自我感觉还行，但翻译基本瞎翻，估计50-80分。政治主观题写满了，虽然 我认为有的原理都写了，但还是抄了一大堆材料，完全不知道怎么估分。。就算40-70吧。专业课算90-120？这样最后估出来应该是280-400。。。TM和没估一样。 然后就一直没什么动力复习复试，也不知道从哪里着手复习（我机试准备用csp抵）。
机试  是打算用csp抵分的，但是前几天群里看到有效期好象是一年，准备用大三上成绩的我菊花一紧（大四9月也考了一次，但是没前一次好，并且语言显示的是all，不知道能不能用），想着还是应该准备下的。就算最后还是抵了，但如果算法和数据结构 不复习，面试被问到也肯定gg。这两周B站找了个数据结构的视频有空看，但是不做习题还是没啥用。翻了下《算法笔记》，里面就是一道一道题，硬去做的话效率也不高。好在我之前准备PAT的时候每题的代码和感悟都还留着，还在微软TO DO上按 专题把一些题目分了类。之后就按之前的记录再刷一遍吧，把每个专题的知识点在博客上整理下。然后还是要刷下北航的机试真题。
  面试     </description>
    </item>
    
    <item>
      <title>在spacemacs中写scheme</title>
      <link>https://iluvata.github.io/post/2021-02-02_scheme-in-emacs/</link>
      <pubDate>Tue, 02 Feb 2021 22:35:46 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-02-02_scheme-in-emacs/</guid>
      <description>参考资料：官方文档 在spacemacs安装scheme环境 在emacs里学习SICP geiser文档
windows安装  一开始看官方文档和 在spacemacs安装scheme环境 做了好久，试图在windows上搭起环境，但是中间遇到好多问题，这里记下几个。。
 首先是 chicken 的安装。文档只说了apt包，但其实pip包也可以？（没试过）。我用的是windows的chocolatey，成功安装了。
 在安装了 chicken 后，为了完整安装对应文档（不知道为什么不能把文档放到同个包里一起安装了。。。），还要运行一下命令：
$ chicken-install -s apropos chicken-doc $ cd `csi -p &amp;#39;(chicken-home)&amp;#39;` $ curl https://3e8.org/pub/chicken-doc/chicken-doc-repo.tgz | sudo tar zx  在尝试用powershell运行第一条指令时提示不存在cp指令中断了。查了好久资料后发现可以用git shell运行成功。
 然后第二条指令其实是运行 csi chicken scheme 解释器后运行 &amp;#39;(chicken-home)&amp;#39; ，结果作为输出，进入chicken安装目录。
 我在安装chicken包时看到安装目录在 c:/tools/chicken 下，就直接转过去了（不知道为什么，解释器中这条命令也运行失败。。）
 最后是在当前目录下载chicken-doc并且解tar包。但我是在windows下，就手动用浏览器访问https://3e8.org/pub/chicken-doc/ 发现有zip包，下载下来解压后放到 c:/tools/chicken 下，这步也算完成了。
 接着按照第二个博客中的步骤，确实可以运行了，但看不到输出也不会报错，重启后甚至又不能运行了。。。
 太折磨人了，明天试下转到linux用第三个博客中的步骤。
  linux安装配置  在 dotspacemacs-configuration-layers 中添加scheme, 在终端安装 mit-scheme 。emacs打开scm文件后 M-x run-geiser ，回到scm文件窗口 C-c C-s 选择mit.</description>
    </item>
    
    <item>
      <title>用easy-hugo在spacemacs中写hugo博客</title>
      <link>https://iluvata.github.io/post/2021-02-02_hugo-with-emacs/</link>
      <pubDate>Tue, 02 Feb 2021 21:52:48 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-02-02_hugo-with-emacs/</guid>
      <description>配置easy-hugo layer  我在github上找到有人写了spacemacs的easy-hugo layer，可以直接用，地址在这里. 把这个仓库中的 packages.el 放到自己的 .emacs.d/private/hugo 文件夹下就可以了. 然后在 .spacemacs 文件中的 dotspacemacs-configuration-layers 中添加 hugo 层.  这时候如果直接运行 M-x easy-hugo 会提示找不到 easy-hugo-basedir ，在.spacemacs 文件夹下的 user-config 项中加上 (setq easy-hugo-basedir &amp;#34;your-path-to-hugo-basedir&amp;#34;) 重新载入就可以运行了。   运行指南  在输入 M-x easy-hugo 进入easy-hugo mode 后，这个layer已经帮我们重新绑定了几个快捷键    Key Binding Description     SPC m n &amp;#39;easy-hugo-newpost   SPC m D &amp;#39;easy-hugo-article   SPC m p &amp;#39;easy-hugo-preview   SPC m P &amp;#39;easy-hugo-publish   SPC m o &amp;#39;easy-hugo-open   SPC m d &amp;#39;easy-hugo-delete~   SPC m c &amp;#39;easy-hugo-open-config   SPC m f &amp;#39;easy-hugo-open   SPC m N &amp;#39;easy-hugo-no-help   SPC m v &amp;#39;easy-hugo-view   SPC m r &amp;#39;easy-hugo-refresh   SPC m s &amp;#39;easy-hugo-sort-time   SPC m S &amp;#39;easy-hugo-sort-char   SPC m G &amp;#39;easy-hugo-github-deploy   SPC m A &amp;#39;easy-hugo-amazon-s3-deploy   SPC m C &amp;#39;easy-hugo-google-cloud-storage-deploy   SPC m q &amp;#39;evil-delete-buffer     如果记不住，按下 SPC 后就会有提示  比如 SPC m n 创建新文章</description>
    </item>
    
    <item>
      <title>hugo 博客配置</title>
      <link>https://iluvata.github.io/post/2021-01-27_hugo-config/</link>
      <pubDate>Wed, 27 Jan 2021 10:58:42 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-01-27_hugo-config/</guid>
      <description> 主题配置  我创建了一个包含整个博客目录的仓库，在这里，以便在不同的地方随时pull下来
 需要注意的是这个仓库中还嵌套包含了另外两个仓库，页面仓库对应public文件夹，以及 dream主题仓库，对应themes/dream文件夹
  02-19注：之前以为删了dream里面的.git就可以直接管理整个博客了，后面发现并不行。需要用 git rm --cached themes/dream 把git子模块去掉
  主题内容配置文件为config.toml，其中配置的路径都是从themes/dream/static文件夹开始的相对路径.
 如配置头像所用的avatar=&amp;#34;/img/avatar.png&amp;#34;实际所在位置为themes/dream/static/img/avatar.png
 修改封面图片：文章添加参数&amp;#34;cover&amp;#34; cover:/img/somepicture.png
 添加tag和category: 在文章头部添加参数tags: [&amp;#34;tag1&amp;#34;, &amp;#34;tag2&amp;#34;]，categories: [&amp;#34;category1&amp;#34;, &amp;#34;category2&amp;#34;]
   插入附件  文章嵌入代码：用#+begin_src和#+end_src表示代码
print(&amp;#34;hello world&amp;#34;)   插入图片：用
[[图片路径]]     </description>
    </item>
    
    <item>
      <title>hugo博客站点搭建</title>
      <link>https://iluvata.github.io/post/2021-01-08_hugo/</link>
      <pubDate>Fri, 08 Jan 2021 15:02:22 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-01-08_hugo/</guid>
      <description>  由于支持emacs org-mode（顺便还能在github上部署），我选择了hugo进行建站。
安装hugo  sudo apt-get install hugo    新建站点  hugo new site /path/to/site  下载主题（我用的是dream） 本地运行
hugo server --buildDrafts -t dream  新建github仓库 云端部署
hugo --theme=dream --baseUrl=&amp;#34;https://iluvata.github.io/&amp;#34; --buildDrafts    写/发布文章  hugo new post/newBlog.org hugo --theme=dream --baseUrl=&amp;#34;https://iluvata.github.io/&amp;#34; --buildDrafts  文章路径为：根目录/content/post/newBlog.org  云端仓库为：根目录/public （在此目录下管理git）  云端文章目录为：根目录/public/post/blog   </description>
    </item>
    
    <item>
      <title></title>
      <link>https://iluvata.github.io/post/2021-02-22_latex-with-emacs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-02-22_latex-with-emacs/</guid>
      <description>— title: &amp;#34;在org mode中嵌入latex&amp;#34; date: 2021-02-22T23:30:15+08:00 draft: false categories: [&amp;#39;life&amp;#39;] tags: [&amp;#39;emacs&amp;#39;] cover: &amp;#39;/img/2021-03-01_latex.jpg&amp;#39; —
 最近写博客发现就算在想着办法避免使用数学公式，在写有关算法，更不用说数学博客的时候还是不可避免的会碰上好多需要使用latex的情况。 于是干脆在这里记一下怎么在org mode中内嵌latex。
 \begin{equation} % arbitrary environments, x=\sqrt{b} % even tables, figures \end{equation} % etc
 If $a^2=b$ and \( b=2 \), then the solution must be either $$ a=+\sqrt{2} $$ or \[ a=-\sqrt{2} \].
 参考链接：官方文档 Spacemacs和Org-mode和LaTeX</description>
    </item>
    
  </channel>
</rss>
