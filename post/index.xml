<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Iluvata&#39;s Blog</title>
    <link>https://iluvata.github.io/post/</link>
    <description>Recent content in Posts on Iluvata&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 28 Dec 2021 15:08:33 +0800</lastBuildDate><atom:link href="https://iluvata.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>结构信息论</title>
      <link>https://iluvata.github.io/post/2021-12-28_structural-information/</link>
      <pubDate>Tue, 28 Dec 2021 15:08:33 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-12-28_structural-information/</guid>
      <description>  给定一个分布，想要描述一个服从该分布的随机变量取值平均所需的信息量就是该分布的熵，也可以理解为该分布的不确定性。信息熵越大，该分布的不确定性越大，完全确定取值所需的信息就越多。例如在一个随机变量有8种等可能取值的分布中，为了确定一个结果，需要一个能够容纳8个不同值的标识。因此用3bit字符串足够描述这些标识。如果分布是非均匀的，则可以对概率大的取值用较短的描述，这样我们能得到一个平均更短的描述。这个 描述的平均长度 就是该分布的信息熵。我们定义某一分布的信息熵如下：
  直观地解释， $l=-logp_i$ 是描述概率为 $p_i$ 的事件的二进制长度，熵就是每个事件的描述长度的加权平均。
 $$H(p) = -\sum_{i=1}^{n}p_i{log}_2p_i$$
位置熵/一维结构熵   高维结构熵   结构熵最小化   </description>
    </item>
    
    <item>
      <title>图嵌入</title>
      <link>https://iluvata.github.io/post/2021-12-28_graph-embedding/</link>
      <pubDate>Tue, 28 Dec 2021 14:11:26 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-12-28_graph-embedding/</guid>
      <description> 图嵌入的通用框架    通常的图嵌入框架有4个组件：
  映射函数：把节点从图域映射到嵌入域
  信息提取器：从图域中提取出关键信息 I
  重构器：从嵌入域重构提取的信息，重构出的信息记为 I&amp;#39;
  优化目标：对 I 和 I&amp;#39; 进行优化，学习映射函数/重构器中的参数
    简单图嵌入  简单图是无重边，没有指向自己的边的图。是静态的、无向的、无符号的和同质的。可以根据想要保留的信息，即信息提取器需要从图中提取出的信息，进行分类。目前这些信息有：
  节点共现
  结构角色
  节点状态
  社区结构
  保留节点共现的图嵌入     </description>
    </item>
    
    <item>
      <title>N1Book Web 学习</title>
      <link>https://iluvata.github.io/post/2021-12-28_n1book-web/</link>
      <pubDate>Tue, 28 Dec 2021 00:17:37 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-12-28_n1book-web/</guid>
      <description>  buuctf n1book web刷题
信息收集  常见的收集  网站上可能会有敏感目录/文件导致信息泄漏，如.git，vim的备份文件.swp等。可以用dirsearch扫描站点目录。
cd dirsearch python3 dirsearch.py -u 192.168.21.128 -e php    -u 指定目标ip
  -e 指定网站语言
  -w 可以加上自己的字典（带上路径）
  –random-agents 使用代理（使用的代理目录在uesr-agents.txt中，可以自己添加）
  脚本扫描的数据库在 db 文件夹，可以自己加。这题的目标文件有三个： robots.txt , index.php~ , .index.php.swp 。我一开始扫了2次没扫出来，指定了php语言后扫出了robots.txt。
 robots.txt是网站定的允许爬虫规则；后缀为~的是gedit的备份文件；.文件名.swp是vim的备份文件。
  粗心的小李  git泄漏题可以用的工具有GitHack，scrabble。只要目标网站上有.git，运行脚本就能把网站dump下来。
GitHack.py http://www.openssl.org/.git/  scrabble http://example.com/      </description>
    </item>
    
    <item>
      <title>pwn堆题整理</title>
      <link>https://iluvata.github.io/post/2021-12-23_heap/</link>
      <pubDate>Thu, 23 Dec 2021 14:55:04 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-12-23_heap/</guid>
      <description>堆溢出  Nnote  花了一周打的UNCTF，光做PWN了，做了7道，就差这道堆题没做出来。最后还有30名以内。。。因为这比赛本身就是入门级的，算是我第一次实战吧。赛后看着wp调试出来。当时应该是找到了漏洞点，但因为基础薄弱最终也没做出来，更别说环境还弄了半天没弄好。。。通过这道题我算是实际开始入门堆了吧。这里是官方wp。
exp环境  题目给的libc是2.31
patchelf --set-rpath ~/glibc-all-in-one/libs/2.31 ./Nnote patchelf --set-interpreter ~/glibc-all-in-one/libs/2.31/ld-2.31.so ./Nnote    泄漏libc  从libc-2.26开始加入了TCache，2.28加入对TCache二次释放的检查. TCache为每个线程加入64个单链表的bins，（64bit系统）以16字节递增，从24B到1032B。每个bins最多放7个chunk。堆开头的0x250的堆块就是tcache_perthread_struct. 在free时，如果chunk大小符合要求，就会在放入fastbins之前放入tcache。分配堆块时若从fastbins中成功返回一个chunk，对应fastbins中其他chunk会被放入对应tcache直到装满。small bins中情况类似。chunk合并时chunk会优先放入tcache。tcache中chunk的PREV_INUSE位和在fastbins中一样不会被清零，因此不会被合并。
 因此这题需要先构造出大于0x410(1040B)的堆块，释放进unsorted bin。需要注意在想释放的堆块后还要再申请一块chunk，防止因为和topchunk相邻而直接合并进topchunk。unsorted bin中如果只有一个chunk，并且这个chunk在上次分配时被使用过时，若申请一个大小属于small bins(32B-1008B)的空间，会直接从该chunk中进行切割，切出低地址部分返回。
 这题申请大小限制不小于0，不大于128，并且根据申请的大小限制了修改时能写入的字节数。但是申请0B的堆块时能通过整数溢出绕过限制条件引起堆溢出。因此这里构造大小为0x480的chunk的方法就是构造9个连在一起的，大小为0x80的chunk（malloc申请的大小为0x78）；然后利用最上面堆块上面的堆溢出覆盖第一块的块大小字段为0x481（块大小字段最低bit为PREV_INUSE）。释放后再申请一个0x80的chunk，会从之前释放到unsorted bin头部割出0x80，导致现在在unsorted bin中的chunk和原来申请的9块中的第二块重叠，输出第二块的数据就可以得到unsorted bin。
add(0) for i in range(9): add(0x78) add(0x18) edit(0 , &amp;#39;a&amp;#39;*0x18+p64(0x481)) delete(1) add(0x78) show(2) __malloc_hook = l64() - 0x70 libc.address = __malloc_hook - libc.sym[&amp;#39;__malloc_hook&amp;#39;]   得到的地址和main_arena(或__malloc_hook)之间的偏移是固定的。可以在gdb调试里看到与__malloc_hook之间的偏移为0x70。
gef➤ bins tcachebins empty fastbins 0x20: 0x0 0x30: 0x0 0x40: 0x0 0x50: 0x0 0x60: 0x0 0x70: 0x0 0x80: 0x0 unsortedbin all: 0x558be3001330 —▸ 0x7f6c92886be0 (main_arena+96) ◂— 0x558be3001330 smallbins empty largebins empty gef➤ x/gx &amp;amp;__malloc_hook 0x7f6c92886b70 &amp;lt;__malloc_hook&amp;gt;:	0x0000000000000000    劫持free_hook  这时候申请两个0x40的chunk，序号分别为11和12.</description>
    </item>
    
    <item>
      <title>ROP</title>
      <link>https://iluvata.github.io/post/2021-11-13_rop/</link>
      <pubDate>Sat, 13 Nov 2021 01:57:10 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-11-13_rop/</guid>
      <description> BROP  确定retaddr的偏移   寻找stopgadget  可以用io.recv()是否成功来判断是否为stopdadget，并且可以根据返回的内容大致猜测覆盖的地址是什么函数
  寻找bropgadget  所谓bropgadget其实就是__libc_csu_init里最后一段包含6个连续pop的汇编，对这段汇编进行偏移还能构造出对于另外几个寄存器的pop。 寻找方法也就是在猜测的retaddr后跟6个trap（会导致程序崩溃的retaddr），再跟上之前找到的stopgadget，最后再跟几个trap。验证的方法可以是在跟上6个trap后不跟stopgadget而是直接跟上trap，看是否会崩溃（如果不会崩溃，有可能是遇到了plt表。为什么plt表不会崩溃？因为plt表用jmp直接跳转去执行函数了）。
  寻找puts/write@plt  通过尝试puts出elf头的\x7fELF确定是否遇到了puts的plt
  dump出内存  用之前得到的puts@pltdump出内存
  在dump出的内存中找到任意函数的got，打印出got内容从而确定libc和偏移   ret2libc     SROP   </description>
    </item>
    
    <item>
      <title>libc泄漏</title>
      <link>https://iluvata.github.io/post/2021-11-10_ctf-libc-leak/</link>
      <pubDate>Wed, 10 Nov 2021 12:35:39 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-11-10_ctf-libc-leak/</guid>
      <description>libc泄漏在pwn题里很常见，在这里整理一下常见的泄漏libc的方法。 ROP中的ret2libc需要知道libc的版本和偏移，需要泄漏内存中函数的地址。 fmtstr中有时需要知道libc的偏移后用system函数覆盖某些函数的got。 堆利用中也会有用system覆盖函数got的利用方式。
常见泄漏方法  未知libc版本时  常用的泄漏方法有泄漏某个函数的got内容，根据泄漏的地址用LibcSearcher搜索libc。函数的got地址可以用ELF在目标二进制文件中搜到。 在可以泄漏任意地址内容的时候可以用DynELF。
    格式化字符串漏洞  NJCTF2017 pingme  这题是blind fmt，只提供了ip和端口。在从内存dump下代码后搜索到printf@got，泄漏出printf地址。用泄漏的printf地址搜索libc-database得到libc版本后在libc中搜到system，用system和printf的相对地址转化得到system在进程中的地址。然后利用fmtstring用system覆盖printf@got。 如果libc-database搜不到，可以用DynELF来泄漏system地址。
def leak(addr): p = remote(&amp;#39;127.0.0.1&amp;#39;, &amp;#39;10001&amp;#39;) p.recvline() payload = &amp;#34;%9$s.AAA&amp;#34; + p32(addr) p.sendline(payload) data = p.recvuntil(&amp;#34;.AAA&amp;#34;)[:-4] + &amp;#34;\x00&amp;#34; log.info(&amp;#34;leaking: 0x%x--&amp;gt; %s&amp;#34; % (addr, data.encode(&amp;#39;hex&amp;#39;))) p.close() return data data = DynELF(leak, 0x08048490) # Entry point address system_addr = data.lookup(&amp;#39;system&amp;#39;, &amp;#39;libc&amp;#39;) printf_addr = data.lookup(&amp;#39;printf&amp;#39;, &amp;#39;libc&amp;#39;) log.info(&amp;#34;system address: 0x%x&amp;#34; % system_addr) log.</description>
    </item>
    
    <item>
      <title>CTF基本工具使用指北</title>
      <link>https://iluvata.github.io/post/2021-09-24_ctf-tools/</link>
      <pubDate>Fri, 24 Sep 2021 14:43:07 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-09-24_ctf-tools/</guid>
      <description>环境搭建  在mac上我觉得比较好用的环境是multipass中ubuntu虚拟机+宿主机中的idapro，以及宿主机上vscode写python wp，在虚拟机中运行。
 multipass默认分配的内存和磁盘不太够用，建议内存分4G，磁盘分15G。ubuntu版本选择16.04. 虚拟机内环境配置可以参考pwn-env-init，建议使用py2. 但是脚本是用apt-get安装pip的，可能会有些问题，需要 curl https://bootstrap.pypa.io/pip/2.7/get-pip.py --output get-pip.py 然后运行 get-pip.py 。还有 one_gadget 目前需要ruby版本高于2.4，apt-get安装的ruby是2.3。可以执行下面的命令安装
$ sudo apt-add-repository ppa:brightbox/ruby-ng $ sudo apt-get update $ sudo apt-get install ruby2.4 ruby2.4-dev $ ruby2.4 -v   还可以装个 tmux ，在pwntools连接gdb调试的时候在开头加上下面代码就可以分出调试窗口（虽然我现在也还没配好pwntools舒服地连gdb的环境。。。）。
context.arch=&amp;#34;amd64&amp;#34; context.terminal = [&amp;#39;tmux&amp;#39;, &amp;#39;splitw&amp;#39;, &amp;#39;-h&amp;#39;]    pwntools  io交互  连接
本地 ：sh = porcess(&amp;#34;./level0&amp;#34;) 远程：sh = remote(&amp;#34;127.0.0.1&amp;#34;,10001) 关闭连接：sh.close()   io
sh.send(data) 发送数据 sh.sendline(data) 发送一行数据，相当于在数据后面加\n sh.recv(numb = 2048, timeout = dufault) 接受数据，numb指定接收的字节，timeout指定超时 sh.</description>
    </item>
    
    <item>
      <title>最大似然估计与基本演绎法</title>
      <link>https://iluvata.github.io/post/2021-04-19_likehood-reasoning/</link>
      <pubDate>Mon, 19 Apr 2021 19:00:13 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-04-19_likehood-reasoning/</guid>
      <description>在数理统计中，极大似然估计是一种使用已知样本来反推最大概率的模型参数的方法。比如我们知道（或者推测）某个 随机变量服从正态分布，但是不知道分布的参数值。如果我们能够获取到几个分布中的样本，就可以对其进行拟合，尝试 得到最有可能的参数值来确定该分布。那具体要怎么通过样本来得到分布的参数呢？
 极大似然估计使用了一种最符合直觉的方法，即使用取到这些样本组合概率最大的参数。这个过程和福尔摩斯使用的基本演绎法 及其相似。在《四签名》中，福尔摩斯在推理凶手的逃跑路线（没想到吧jojo，这就是我的逃跑路线啊，wryyyyy 23333） 的时候说，当你排除了所有不可能的情况后，剩下的，不管多不可能，就是事实。类似的方法还在《巴斯克维尔的猎犬》中 福尔摩斯推断来访者身份以及许多其他地方中使用过。如果把你扔到二等车厢，让你指出每个人的职业，你会怎么做。首先 当然是对对象进行观察，观察他们的衣着，膝盖，手腕，衣领。得到的结果，比如说一个人的膝盖上有泥土，就是数理统计 中的样本。给定了一系列的样本，如手腕上有粉末，衣领上有灰，脚上穿着皮鞋，戴着眼镜；这些结合在一起得到了样本空间。 我们会怎么推断这个人的职业呢？符合这些样本情况的职业可能有很多，还可能有一些样本是由于一些意外的活动引起的。但是一般 来说，我们不会把这个人的职业判断成运动员。尽管由于一系列的小概率事件使得一位运动员打扮成这样，但我们的推理是基于 最有可能导致这些样本的情况进行的。这也就是最大似然的思想方式。
 回到概率统计中，那在数学上该如何计算参数值呢？我们将几个样本值分别带入分布公式，要求的参数作为变量，将每个样本 得到的对应概率表达式相乘作为联合概率（需要各样本相互独立），把取到使得该联合概率最大的值拿来当作目标参数值。 再往下更具体的计算步骤包括处理联合概率（即极大似然目标函数），希望求解使其最大化的最优化问题。一般的方法是 对其做对数处理，然后求导，使得导数为0的参数值能让目标函数取到极大值，就是我们要求的值了。</description>
    </item>
    
    <item>
      <title>迭代与递归</title>
      <link>https://iluvata.github.io/post/2021-04-07_iteration-and-recurtion/</link>
      <pubDate>Wed, 07 Apr 2021 16:03:50 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-04-07_iteration-and-recurtion/</guid>
      <description>递归处理与递归过程  用一个经典的递归例子：阶乘 来说明。
(define (factorial n) (if (= n 1) 1 (* n factorial (- n 1))))  以上是经典的阶乘的递归处理，若输入为1则输出1,否则结果为当前n×递归执行n-1.
(define (factorial n) (fact-iter 1 1 n)) (define (fact-iter product counter max-count) (if (&amp;gt; counter max-count) product (fact-iter (* counter product) (+ count 1) max-count)))  以上是阶乘的迭代处理。我们在每一次迭代（循环）中输入了得到下一结果所需的所有信息，编译器无需像在递归处理中一样 保存每次n的值以计算最后的结果。
 但是用我们熟悉的c语言来理解以上这段代码，我们会觉得在形式上 fact-iter 函数在函数体中调用了自身，也应该算作 递归而不是迭代。在c语言中，我们理解的迭代是使用 for 或 while 在代码块中显式地更改变量，以上代码很明显 没有使用“循环”。这就引出了递归过程与递归处理的区别。以上代码使用的确实是我们在c语言中称作“递归过程”的代码形式， 但根据我们对“迭代处理”的定义，即编译器无需保存中间变量，它很显然是符合“迭代处理”要求的。在c语言和其他很多 语言中，使用递归过程的迭代处理会和普通的递归处理一样，在每次递归中保存一些值，导致无法到达很深的递归深度。在lisp 编译器的实现中使用了“尾递归”优化技术，即若一个函数在调用自身时（满足递归过程条件）将该调用放在最后执行，并且 无需保存多余的变量，将所有必要的变量输入下一层，那么编译器在执行的时候就不会保存多余的信息，而是像迭代那样直接 用下一层来覆盖当前层。
  多种形式的递归与迭代  线性递归  上面factorial的递归实现中每次进入一个下一层，保存的数据随n的增大是线性增长的。这种形式的递归处理叫做线性递归。</description>
    </item>
    
    <item>
      <title>末流211考研北航计科学硕430分经验帖</title>
      <link>https://iluvata.github.io/post/2021-03-29_postgraduate-exam-experience/</link>
      <pubDate>Mon, 29 Mar 2021 23:03:25 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-03-29_postgraduate-exam-experience/</guid>
      <description>  先说下我的基本情况。我本科是云南大学，六级一年没学英语，裸考485；四级考前做了几张卷子，602. 在大学专业课和绩点都一般，数学可能稍微好些，基本就是平时自己做下作业，考前突击下，能考九十多（考的很水。。）。 考研成绩是政治74，英语80，数学138，专业课138. 我正式准备考研是从5月中旬开始，每天早上3小时数学，下午2-3小时专业课，晚上2小时数学习题；每周休息半天，差不多这个节奏一直到考前。英语和政治没有专门划时间，夹在休息时间里学。还有就是虽然安排是每周休息半天，其实中间可能有几天也在划水没学习。。
初试  政治  政治可以准备的晚一些。但我比较怂，从7月就开始每天晚上看一集徐涛的课，看一章后做一章的1000题。本来还买了精讲精练，却没怎么翻过。。后面又买了徐涛的小黄书想看看有什么不一样的，还可以跟着课在书上划。但是划了几天后感觉这样反而会降低上课的专注度，不如自己做笔记，或者如果懒得做就直接听，都比为了找书上对应的地方经常跟不上课程节奏要好得多。而且小黄书编的我感觉确实不如精讲精练，没有突出重点，只是一个接一个列知识点。说句题外话，我感觉马原中的“实事求是”确实非常适合考研。如果你是一个坚定的唯物主义者，就不会寄希望于考试刚好考到你会的知识点，也能认清自己和大神的差距，不会幻想不用努力知识就直接跑进脑子之类的奇迹。看到自己和别人的进度差距后要做的是脚踏实地，一步一步慢慢走，一点一点慢慢啃书。囫囵吞枣带来的心理安慰没有一点用。在书上划线和做一大堆笔记也只是起到心理安慰的作用，要做的笔记不是好看的笔记，是方便自己复习的笔记。上课不是为了划线，是为了听懂。因此光顾着划线却没仔细听讲，不如啥都不干就坐着听课的效果来的好。关于作息也是一样，早上一大早起床导致一上午昏昏欲睡不如睡到自然醒。整天泡图书馆有时候反倒不如中间去操场玩几个小时。只有自己知道今天到底有没有真正用功，表面上谁都看不出来。说回正题，在8月我找到了一个题库小程序小白政治，每天午饭后在上面刷一节。这样一直到10月终于把1000题刷完了。。我花了两个晚上理了一下时间线和知识点后就没二刷，开始看腿姐的技巧课。每天也听腿姐在喜马拉雅的带背，买了她的背诵手册早上抽点时间背后面的知识清单。还买了肖秀荣的几本小册子，但没看。。肖六出了后做了上面的选择题。在记乎上买了一份各种政治模拟卷选择题合集，每天几十道反复刷。我感觉这时刷的选择题应该是对我提分起的作用最大的。第一遍做1000题和小白的时候正确率一般在50%左右，可能高些。。做肖六平均有35吧，后面的肖四也差不多。。肖四出了后先做了选择题。最后2周才开始准备政治的主观题。肖四一共20道大题，每天背2道背到考前。考前几天做了唯一一次模拟（也是唯一一次写主观题），感觉对把握时间还是很有帮助的。
  英语  我从年后就开始用app背英语单词，一直背到考前。中间虽然换过几个app（从百词斩换到默默，到扇贝，最后到欧陆），但app上还是一直在背的。4月开始买了恋恋有词按记忆曲线背list。6月开始每天中午午休抽点时间做两篇阅读，到9月把05年到20年共15年的阅读做了2遍。05年再往前的做过一张，感觉题型有点不一样（错的很多。。）就没做了。我第一遍做阅读大概一张卷子错3-4个吧，第二遍可能2-3个。。9月开始做完型和新题型，10月开始练作文和套卷。因为阅读已经是第三遍了，答案可能很多都能背下来了，就基本没多少错。我开始练作文时先大致翻了潘赟的作文书（不推荐买实体书，感觉内容有点虚，pdf完全够用），在margin note上把书里的内容整理成思维导图，熟悉了作文大致的框架（考研作文感觉蛮八股的，都是一个套路），然后每周练2-3篇，自己写完后看范文结构，整理一些句子。到最后一共练了十几篇作文。11月在网上找了一些关于作文的帖子，背了一个万能的结尾段，前两段靠积累的结构和句子到考场临场发挥。 总结一下我英语就是一直背单词，背了至少5-6轮；做了3遍近15年阅读；整理了一下作文结构。
  数学  虽然4月就看到群里好多人数学进度已经甩老远了，也一直蛮焦虑的，我正式开始准备却一直拖到了5月中旬。开始的时候看到李永乐的线代视频课，本来想试试水，结果看着感觉还行就直接跟着从线代开始了。花了一周看完了20年的线代强化课视频，在他的辅导讲义上做了好多笔记。然后开始啃李正元全书。每天早上3小时用来看全书，晚上做对应的1800高数基础题，这样一直到8月前差不多结束一轮。很多时候晚上做题的进度跟不上早上看全书的进度（我一般每天只能啃10页，把每道例题都做一遍），就直接跳过了那个章节还没做完的题，和上午的进度同步。 第一轮啃全书的时候感觉有些地方说的可能不是很全，就买了本张宇18讲想看看有没有补充，结果发现基本上知识点是差不多的。。既然买了18讲，第二轮就顺便用它了。7月开始第二轮，早上3小时用来看张宇18讲的网课，晚上做对应的题，花了一个半月刷完了。做了后我感觉不是很推荐张宇，他出的题和书里总结的解法有些感觉很怪，真正考研不会用上（凭我后来刷的15年真题和实际考试感受得到），对比李正元的书总结的就很舒服。第二轮做完高数后线代和概率一起上，上午做余炳森的概率（群里推荐的，书确实整理的蛮好），晚上做李永乐的线代辅导讲义（第一遍的时候还有好多题没做，而且这时前面只花了一周学的线代知识已经忘的差不多了）。周末会做660。今年的660还是比较简单的，特别是线代和概率部分，因此做660总共花的时间并不多。第二轮差不多在9月中旬完成。这时看到李林的书便宜就下单买了（三本讲义一共9.9包邮），翻了下发现里面高数讲中值定理和泰勒公式比较详细，刚好可以弥补李正元全书的不足。就花了2周把那两章做了一遍，整理后感觉确实收获颇丰。做660的时候开始整理错题到错题本上。我感觉第一轮完全不需要错题本，到第二、三轮错题本可能才能发挥上用场。每周会花半天到2天的时间来做错题本，每次上面做的题会做个熟练度标记，下次把熟练度低的题重新做一遍。经常会有做过几遍还是不会做的题，可能这就是没什么天赋的人的日常吧。。。 二轮结束后感觉做题还是不太行，网上下了李林880做了一些感觉出的确实不错，就买了实体书。这时我看网上别人已经真题都刷到第二遍了，我却还没碰过真题。。但按照自己的节奏来确实还是蛮有必要的。事实证明，到最后开始刷真题的时候我虽然只刷了一遍，但感觉完全没必要刷第二遍，而且时间充裕的后期甚至不知道做什么。。李林880题量还是有点大，这之后全部做不太现实。好在李林在微博和公众号上给划了重点题，我就只做了他划的那些题。9月中到10月底我数学安排是早上做880重点题，晚上做108题。中间花了2周早上改做李林高数讲义里的中值定理。这时每周开始把周日拿出来做真题，早上3小时做一张数学，下午一张961，晚上来对答案整理后继续做108. 11月开始每天刷真题。这时感觉任务反倒减轻了，早上一张卷子一般2个小时多能做完。真题做到头基本没有不会的题目，但是每次都因为粗心扣个十几分，只有两三次能拿满分。李林6套出了后渐渐的真题差不多做完了15年，开始做模拟题。模拟题做了李林的6+4和合工大的共创5套。感觉做着比真题要卡些，但也还行。后面有的时候会感觉没什么试卷好做，但还是得每两天刷一张数学卷子来保持手感，否则容易忘知识点。试卷不是用来打分的，是用来查漏补缺的。就是把考研的知识点全覆盖，你做完看看还有没有没掌握的，要是有就可以去那些地方专门强化。为了多刷点卷子巩固知识点，刷完15年真题和几张模拟题后我怕剩下的卷子数量撑不到考试（李林和合工大是网上一致评价质量好的卷子，质量差的卷子我感觉不接近真题刷了也没用），我试着做了几张05年之前的老真题，但感觉太简单了，根本没必要。。
  专业课961  专业课我也是从5月中旬正式开始的。5月到7月每天下午两个多小时做王道，看一章做一章题，答案不直接写到书上。顺序是计组-操作系统-计网。计组中间对应的汇编指令和CPU两章啃黑书，但王道的题最好也还是做做，我后面在961真题上找到过王道在那两章里的题。8月差不多到2轮。2轮就只大致看了每章内容，做了选择题，还是没把答案写书上，但标记了错题。中间花了2周做了黑书上的习题（做那个真的花时间。。），对理解还是起到很大作用的。我看很多学长学姐说MIPS CPU的几张图要背下来，但我记忆力不好，背不下来。。后面做真题发现还是理解更重要些，961真题一般不会直接给书上一模一样的结构，会在一些旁路上做些手脚，让你自己分析有什么影响。二轮的顺序是先计组和操作系统隔天轮换，两门看完后看计网。9月底开始3轮。第三轮主要是理清每章的知识结构，自己整理一份导图（我发现自己画一幅比看别人整理的要有用的多），最好能给别人讲解三门课教了什么。每章王道都细看一遍，课后题只看前面标记的错题，大致看下大题。这次是每3天3门课轮换。在2轮和3轮之间我花了一周做了961真题的选填（一共就5张），提前了解下真题。3轮还看了北航的课件。结束差不多是10月中旬，王道买的408真题和模拟题刚好发货。开始第4轮，一天做408卷子一天做王道课后题。这次直接写到书上了，而且没怎么看前面的知识点，要看也是看自己整理的导图，所以很快就写完了。而且这是第4轮了，差不多题目也都背下来了。。。这遍应该是在快12月的时候结束。后面试着做了几张王道的模拟题，出的那叫一个一言难尽，屎一样！去刷刷选择题还行。至于大题，别看。12月以后就是做961真题了。计划是每2天一张，但因为中间摸了好多鱼，拖到考前一周刚好做到最后一张用来模拟。
    复试  机试  我的机试是用CSP 320分，2.8%抵的。其实我是考了CSP后看到北航能换分才考虑考北航的2333. 我觉得要是有机会去考，考了换分应该是很划算的，可以在准备复试的时候减轻很多心理压力。前两题200分就是送的，而直接拿200分去换也不会亏（大佬除外）。还有就是先考一次这个能让自己有考北航的信心。如果准备了后还考不到200就算进了复试机试也很容易被刷。我没有为这个考试特别准备过，考了两次都是直接上的。第二次是考研的9月，半年没写代码了直接上考了300. 第三题细心点，别着急慢慢写就行。可能是因为我的面试比较差，初试第5，复试后总分第7.
  面试  考完后完全没什么心情准备面试，还去实习了。出分前更是一点底都没有，甚至不知道自己能不能进复试（我自己估分最低是280。。），就在每天上班前看一会离散。后面开始每天写博客整理可能会被问到的课程和项目。结果准备的课基本都没问，问了几个很基础的问题。我们是网上面试，一进去先让抽一道政治。然后是英语自我介绍。说完后老师用英语问我最常用的编程语言是什么，我说cpp。然后问有什么难点，我说了一些面向对象的特性比较难记忆和理解。英语完了后是线性代数，问我怎么解线性方程组Ax=b，还有怎么判断一个向量组无关。之后是离散，问了偏序，全序，良序是什么。然后是数据结构，问给一个文本，怎么统计每个词的词频。我说python可以用字典，C++可以用Map，老师说他问实现的数据结构是什么，我说红黑树。老师继续问我红黑树的细节是怎样的。。我答不上来，就说了还可以用二叉排序树，用字典序进行排序，找到后给节点的记数+1，找不到就新建节点。老师问复杂度是多少，我说对数复杂度。然后老师还问我知不知道多态是什么，我说了一大堆，后来想想应该是答错了。。最后问了我有什么项目，我说了一半时间就到了。
    后话  我的考研经历大致就是这些了，希望对你们有点用吧。中间我省了很多废话，要是对一些更详细的细节感兴趣的话可以看下我的博客，里面更详细的记录了一些我的学习方法啥的，虽然更多的是废话哈哈.总结起来我感觉我自己的考研之路还是相对比较轻松的，特别是后期疯狂摸鱼，又是跑步又是看小说，考前两周还因为在大冷天跑步后冲凉把自己送进了医院。。。考完后我自己的估分是280-400，出分的时候突然跳出来430我着实是吓了一跳，看来改卷并没有我想象的那么严格2333.最后祝大家都能考上自己喜欢的研究生，欢迎到然姐的北航考研群473862594，或直接找我1124026683问问题。
  </description>
    </item>
    
    <item>
      <title>概率统计中的分布</title>
      <link>https://iluvata.github.io/post/2021-03-19_distributions/</link>
      <pubDate>Fri, 19 Mar 2021 14:52:58 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-03-19_distributions/</guid>
      <description> 连续分布  均匀分布   正态分布  距离某一中心值偏离的误差越大的概率越小。可用于自然界许多现象的模拟.
  指数分布  EX=1/lambda DX=1/lambda^2 指数分布的无记忆性：先验概率与后验概率相同。可用于模拟电器使用：不管之前使用了多久， 能继续使用x小时的概率不变。 先验概率 后验概率
    离散分布  0-1分布  0-1分布随机变量取值为0或1，参数只有一个p，即取值为1的概率。
  二项分布  二项分布是多个相同0-1分布的叠加。B(n,p)中n为随机变量的数量，p和0-1分布中相同。 输入k得到的结果为k个随机变量得到1的概率。
  泊松分布  EX=DX=lambda 在二项分布数值非常大的时候B(1000, 0.001), n=1000, p=0.001的时候计算量非常大。 可以用泊松分布进行模拟。lambda=n*p, 随机变量为k. 经常被用来模拟排队。在每个离散时间一个客户可能来的概率为p, 泊松分布可以模拟 总客户数为n时在时间点k来的客户数量。
    </description>
    </item>
    
    <item>
      <title>推荐系统基础</title>
      <link>https://iluvata.github.io/post/2021-03-18_recommending-system-basics/</link>
      <pubDate>Thu, 18 Mar 2021 07:44:33 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-03-18_recommending-system-basics/</guid>
      <description> 从线性回归到FM   特征工程  特征工程是将原始数据转化成更好的表达问题本质特征的过程，使得这些特征运用到预测模型中能 提高对不可见数据的模型预测精度。
 直接将时钟的图片点阵输入一个网络进行训练，希望得到当前时间。虽然可能有些效果，但是网络 内部需要学习图片代表的意义，多了一层学习成本，得到的效果可能会较差。如果预先将图片处理 成三根指针指向的方位，作为输入得到的效果会好很多。这个从图片到方位的过程就是特征工程.
  MF矩阵分解   协同过滤和基于内容的推荐系统   </description>
    </item>
    
    <item>
      <title>操作系统</title>
      <link>https://iluvata.github.io/post/2021-03-17_operating-system/</link>
      <pubDate>Wed, 17 Mar 2021 19:33:08 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-03-17_operating-system/</guid>
      <description> 操作系统的模块  操作系统是在裸机之上，为用户提供资源管理服务的软件。需要管理的软硬件资源包括CPU，内存， 外设等。与之对应，操作系统大致可以分为5个子模块：CPU管理模块，内存管理模块，文件系统， IO管理模块。
  进程和处理器调度  进程是程序的一次执行。但是进程是计算机中活动的状态，随着时间改变保存的数据，而不是像程序 那样，静止地保存在磁盘中。关于进程的讨论包括进程的状态，通信，同步互斥，死锁。在多道程序 操作系统中CPU不能一直被同一进程占据，需要进行调度，决定每个时间由那个进程占用CPU。CPU 调度的形式包括先来先服务，短作业优先法，时间片轮转法，优先级调度法，高相应比优先， 多级队列轮转法等。死锁是两个或以上互斥进程在执行过程中占据对方需要的一部分资源的同时请求 的部分资源被对方占据，造成的阻塞，无法向前推进的状态。死锁的必要条件有临界资源互斥执行， 不可剥夺已有资源，在占有部分资源的情况下进行请求，以及请求形成环路循环等待。处理方法有 预防，避免，检测和恢复。死锁预防是指破坏4个必要条件中任意一个；避免是用银行家算法，在每次 请求保证之后的状态是安全的才分配资源；检测使用资源分配图。
  内存管理，虚存   文件系统   IO子模块   </description>
    </item>
    
    <item>
      <title>计算机体系结构与组成原理</title>
      <link>https://iluvata.github.io/post/2021-03-15_computer-structure/</link>
      <pubDate>Mon, 15 Mar 2021 13:13:42 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-03-15_computer-structure/</guid>
      <description>计算机体系结构概要  计算机体系结构讲的是同系列计算机为操作系统提供的接口（包括机器语言、汇编语言等），以及底层 硬件的结构设计。计算机组成原理讲的是硬件实现。目前的计算机一般都是用冯诺依曼结构，特点是 存储程序，即将程序作为数据和数据存储在同一存储器中。要执行程序的时候从第一个存储单元开始 顺序执行，根据控制流跳转。与之对应的是哈佛结构，将数据和程序分别存放在两个不同的存储器 中。
 要了解计算机，首要的是了解计算机是怎么存储数据的。包括补码、原码等各种格式和他们的运算。 在了解了数据在计算机中的表示方式后，我们需要知道他们在哪里如何被存储，在哪里怎么进行运算。 在了解计算机进行运算的步骤之前需要知道计算机是用什么格式发出命令的，即机器语言与汇编语言。 以上便是计算机主机的任务：存储、运算、控制。除此之外，计算机还需要规范数据如何在各部件间 传输，即确定总线的相关标准。最后，如果只有之前的操作我们只能将计算机看作一个黑盒，什么都 进不去，什么都出不来，就算一直在计算也没有用处。因此对于输入/输出的讨论也极为重要。
  现代计算机中，控制器和运算器一起被叫做CPU，CPU和主存一起组成主机，主机与外设一起组成硬件设备。 硬件和软件一起组成计算机系统。
  存储器层次结构  目前我们能用于做存储器的材料与工艺有很多，不同方式/目的做出的存储器特性也不同。如磁盘，磁带， RAM，ROM，FLASH等。存储器的分类方式有很多，如用用掉电后能否保存数据可以分成挥发性存储器与 非挥发性存储器；能否随机访问可以分为随机访问存储器与顺序访问存储器等。除此之外，就算是在 主机内部使用的存储器，不同工艺也有很大的性能与价格差距。SRAM可以用于寄存器，速度最快， 但是集成度低，在单位空间内塞不下很大容量，并且价格贵。DRAM动态随机访问存储器一般用于主存， 相比SRAM速度较慢，但是集成度较高并且便宜。
 我们对计算机性能的要求是无上限的，但同时成本也需要控制在可接受的范围。因此就算我们让一台计算机 主机内所有的存储器都用SRAM，我们还是会想要更大更快的内存。为了解决上述价格与速度的矛盾，我们 引入了分层次存储器。在拥有DRAM作为主存的大容量低价格的同时使用SRAM作为CPU内部寄存器以获取高速度。 完整的层次结构中速度从快到慢，容量从小到大是：寄存器-cache-主存-外存.
 主存与CPU之间通过总线相连，数据从主存中取出到寄存器中，在寄存器中传入ALU等部件组成的数据通路进行 计算，得到的结果也存放在寄存器，需要时写入主存中。随着硬件的发展，虽然主存的速度也在不断增长， 但CPU速度的增长速度远大于主存，两者之间的速度差距越来越大。为了调节两者间的速度差异，最大 程度发挥CPU性能，Cache作为高速缓存被引入。Cache具有接近CPU的存取速度，保存最近常用的主存中 的单元副本，并且实时更新。主存、Cache、CPU之间的关系，乃至整个存储器层次结构中上下层软硬件 的关系，我们可以形象的用柜台和仓库进行类比。存取速度更快但是容量更小的上层存储器是商店里的柜台， 下层存储器是商店的仓库，数据是仓库中的物品。当用户/计算机需要购买物品时，如果柜台中有物品 就可以直接从柜台快速拿取，若没有则需要经过繁琐的步骤去仓库取出。但是我们不能把仓库中所有物品 直接放入柜台。还有一种类比是把数据看作学生使用的文具，最上层，即速度最快，容量最小的一层是 学生书桌上的文具盒，需要的时候可以随时取用。下一层是书包，可能有些较大的文具无法放在文具盒中， 这时就需要花稍多的时间从背包内取出。再下一层可以是学生的家。有时候可能会把要用的东西落在了家中， 或者书包也装不下，只能放在家中。这时若再需要用到就要花大代价跑回家去拿。但是一旦从家中拿到了 文具，已经将它装在了包里，那下次再次取用就只要去包里找就行了。CPU内寄存器、Cache、主存间的关系 大致是这样，只是这里的“物品”：数据是可以被拷贝到上层存储器的，从下层“取走”到上层后下层还保留着 一份原本，上层只是“复制”走了一份副本。值得一提的一点是为什么我们每天只需要一个包来装学习用品 就够日常使用了，而不是经常跑回家拿东西呢？假设我们把所有科目的书和试卷等全都放在家里，每天的 课程表让我们知道当天的科目，再加上当前的课程进度，综合起来我们可以判断只需要带走一部分相关的资料 而非全部科目的所有资料就足够当天的学习使用了。在计算机中也有类似的情况，就是计算机在执行一道 程序的时候在一段时间内会反复使用同一段或相邻的空间。这就相当于得知了当前的“课程进度”和“课表” 后，我们能够确定大致需要带的资料，在一段时间（比如一天）内无需反复回家更换。程序在一段时间 内反复访问相同的空间的特性叫做时间局部性，访问某空间后大概率访问相邻空间的特性叫做空间局部性。 程序的局部性原理使得是的Cache能够作为CPU与主存间的高速缓存大大提升整体系统的效率。
 那么我们在使用Cache的时候需要注意哪些细节呢？首先，由于一个学生在上学的时候不可能把整个家里所有 东西都装在背包中，需要挑选出每天要带走的东西。Cache需要确定保存哪些副本，当空间满了的时候 如何进行替换。Cache的替换策略有随机替换, FIFO, LRU, LFU. 其次，Cache中保存的是主存中的副本， Cache以行为单位，一行内可以包括多个主存单元（一般是1字节大小），与行对应大小的单位在主存 中被称为块。Cache最理想的实现方式是每行都能保存主存中任意块的副本，但是由于Cache的总 容量比主存小，我们需要对存在每行中的每个块指定一个标识以分辨对应主存中的位置。 按照上面的设想，我们需要在每行保存完整的主存块地址（非存储单元地址，用于分辨块中不同存储 单元的最后几位不用记录）作为唯一标识，这样每次想要找出CPU给出的主存单元对应的Cache行所需 的开销就会比较大。那么我们可以换一种思路进行映射：由于主存容量较大，地址的长度也比Cache中地址要长， 那我们把高位多出来的那部分作为唯一标识，剩下的主存地址就直接用到Cache上当作行地址，这样需要保存 的标识长度就短了很多，每次在Cache中找对应的主存块也不用对比所有行的标识，只需找到编号低位 与地址相同的那一行。以上两种Cache与主存之间的映射方式分别是全相联映射和直接映射。有的时候， 我们虽然用不起全相联映射，又发现直接映射太过于死板以至于在跑一些程序的时候无法很好的 完整高速缓存的工作（无法很好利用时间局部性），那就可以将两者结合起来，先将Cache中的行分组， 在组内进行任意对应。这就是组相联映射。</description>
    </item>
    
    <item>
      <title>编程语言的基本组成</title>
      <link>https://iluvata.github.io/post/2021-03-14_basic-elements-for-programming-language/</link>
      <pubDate>Sun, 14 Mar 2021 22:50:46 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-03-14_basic-elements-for-programming-language/</guid>
      <description>编程语言的基本组成  编程语言的基本组成是SICP的第一节讨论的内容。编程语言所需要的基本元素有3个：原子元素（原子过程、 原子数据结构）、将运算进行复合的能力、对过程进行抽象的能力。
 原子元素是语言本身提供给我们的最小过程与数据结构，如乘法 * ，整数数据类型. 在scheme中我们将 一个操作过程写在括号语句内，语句的第一个元素作为运用的过程（操作符），随后的元素作为操作数。如
(* 3 4)   运算复合的能力使我们能够从基本操作中构建复杂操作，如求解阶乘
(define (factorial n) (if (&amp;lt; n 2) 1 (* n (factorial (- n 1)))))   最后是构建抽象的能力，能够让我们不被所有实现细节扰乱思路，只把之前构建的函数当作黑盒直接拿来 使用
(factorial 4)    块结构–以牛顿法求平方根为例  牛顿法是用于求解方程根的算法，从一个猜测开始每次迭代得到一个更好的猜测，不断向根逼近，直到 一个我们指定的要求达到为止。 通过使用抽象和运算符合的能力，我们能够构造improve, good-enough?等方法，最终构造出我们想要的 sqrt算法。
(define (sqrt-iter guess x) (if (good-enough? guess x) guess (sqrt-iter (better-guess guess x) x))) (define (sqrt x) (sqrt-iter 2.0 x))  在求解的过程中，我们定义的一些方法只有在sqrt中才会被用到，如improve, good-enough?等。为了 防止和其他代码名称冲突，可以把他们全都放到sqrt的定义内，让他们的作用域只限于sqrt.</description>
    </item>
    
    <item>
      <title>推荐系统的鲁棒性</title>
      <link>https://iluvata.github.io/post/2021-03-11_recommend-system-robustness/</link>
      <pubDate>Thu, 11 Mar 2021 07:43:55 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-03-11_recommend-system-robustness/</guid>
      <description> 推荐系统概述  推荐系统通过建立用户与产品间的二元关系，利用用户已有的选择过程或相似性关系挖掘每个用户 潜在的感兴趣对象，进而进行个性化推荐的系统。根据其推荐原理的不同，大致可以分为
  协同过滤推荐算法
  基于内容的推荐算法
  基于用户-产品二部图关系的推荐算法
  混合推荐算法
  其中协同过滤算法“利用用户已有的选择过程推荐”；基于内容的推荐算法“利用用户或物品间的 相似性关系”；基于用户-产品二部图关系的推荐算法是利用图论的方法进行推荐，类似于PageRank算法。
  推荐系统评价指标  我们一般在评价推荐系统的时候使用的是准确率和召回率。   正确率 = 提取出的正确信息条数 / 提取出的信息条数   召回率 = 提取出的正确信息条数 / 样本中正确的信息条数   准确率给出提取的信息中正确的比例，召回率给出所有正确信息中被提出的比例。除了常用的两个 指标，用于衡量推荐系统的还有以上两者加权调和平均的F指标，平均绝对误差MAE，平均平方误差MSE（用于 给出评分数值的系统）等。在除了准确率之外，我们有时候希望从一些别的方面对推荐系统做出评价， 包括推荐物品的多样性，新鲜性，用户满意度，可解释性，鲁棒性，公平性等。这里主要讨论推荐系统的 鲁棒性，即在受到破坏（如注入虚假的用户访问记录和用户信息，刷好评，数据缺失）的时候正常工作 的能力。
  推荐系统鲁棒性   参考链接： 个性化推荐系统研究 个性化推荐系统评价方法综述 通过伪造共同访问对推荐系统进行攻击 全能的FM模型
  </description>
    </item>
    
    <item>
      <title>文件系统与数据库系统</title>
      <link>https://iluvata.github.io/post/2021-03-09_file-and-database/</link>
      <pubDate>Tue, 09 Mar 2021 11:40:13 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-03-09_file-and-database/</guid>
      <description>数据库系统  数据库系统的组成部分包括数据库、软件、硬件和用户。数据库指的是系统中各种数据，包括目标数据 和描述数据。软件包括DBMS和开发工具等。 我们一般使用的数据库系统都是关系型数据库，这里将谈论的也主要是关系型。NoSQL之类的非关系型 数据库以后有时间可以去了解一下，我目前的理解是非关系型数据库可以支持使用一些更灵活的结构来 进行数据的存储，如json，可以避免数据结构多样性带来的问题。除了目前最常会用的关系型数据库外， 其他数据库结构还有层次模型和网状模型。
 数据库系统的层次结构如下
 软硬件层次
  DBMS管理层次  关系型数据库中的“关系”即我们在离散数学中学过的关系(relation)：多个集合的笛卡尔积的子集。 只是我们在离散数学中讨论的一般是二元关系，只考虑两个集合。在关系型数据库中，我们考虑的范围 变成了n个集合，即数据库一张表中的n个字段。对于讨论n元关系的关系型数据库，我们能够进行的基本 操作有SELECTION, PROJECTION, JOIN. SELECTION与SQL语句中的查找语句一样，从表中找出满足 条件的语句。PROJECTION删除一些字段，只留下（展示）我们需要的字段。JOIN得到两张表的笛卡尔积。
数据库三范式  数据库在设计表结构的时候为了减少冗余，避免在对数据进行操作时产生问题，需要遵循三范式。第一范式： 所有字段存储的都必须是最小的原子字段，不允许像结构体这样的复合结构。第二范式：所有字段必须完全 依赖于主键。如选课表(课程id，学生id，学生姓名，分数）中学生姓名没有完全依赖于主键（课程id，学生id）， 需要新建一个表（学生id，学生姓名）。否则每次存入相同学生id不同课程id的数据时都会存入相同的 学生姓名，增加了不必要的数据存储导致冗余。第三范式：所有非主键字段直接依赖于主键，不能存在传递依赖。 学生表（学生id，学院id，学院电话）中学院电话通过学院id传递依赖于主键学生id，需要拆分出（学院id，学院电话） 表。第三范式还可以用另一种形式表达：非主键间不能有依赖关系。BC范式在第三范式的基础上进一步限制 了主键间也不能有依赖。表（学生id，老师id，课程id）中，每个老师只能教一门课，每门课程可以有多个 老师，每个学生选了一门课后有对应的一名固定老师。表中三个字段都为主键，但是老师和课程之间存在依赖。   数据库事务  在对数据库进行操作的时候，我们希望有一些操作序列不可被分割，要么全部执行，要么不执行，中间没有别的 操作插入。数据库系统提供了把多条作为一个整体进行操作的功能，把这种整体称为事务。事务具有ACID特性： Atomicity原子性，Consistency一致性，Isolation隔离性，Durability持久性。原子性是我们之前说的 要么所有语句全部执行成功，要么全部不执行。一致性是指事务执行前后特定状态保持一致，如转账操作前后的 转账双方的总金额。隔离性是多个并发事务之间不能互相干扰。持久性是事务提交后的改变是持久（永久）的， 不会丢失COMMIT.
 如果我们不考虑事务的隔离性，可能会发生的情况有：
  脏读：事务在提交前的修改被读到
  不可重复读：事务内的几次查询间别的外部语句修改了数据，导致一次事务中相同的读得到不同数据
  虚读（幻读）：一个事务内对数据进行操作时别的外部语句修改了数据，导致对被修改的记录的操作失败
  不可重复读与幻读的区别是不可重复读查询同一数据项，幻读操作一批数据。
 为了提供不同场景对隔离性的需求，对于事务的隔离性定义了4中隔离级别：读未提交(read uncommitted), 读提交(read committed), 可重复读(repeatable read), 序列化(serializable). 序列化可避免脏读、不可重复读、幻读；可重复读可避免 脏读、不可重复读；读提交可避免脏读；读未提交无法保证任何情况。</description>
    </item>
    
    <item>
      <title>欧拉环路和汉密尔顿环路</title>
      <link>https://iluvata.github.io/post/2021-03-04_euler-circuit-and-hamiltonian-circuit/</link>
      <pubDate>Thu, 04 Mar 2021 17:54:59 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-03-04_euler-circuit-and-hamiltonian-circuit/</guid>
      <description>图论中有两种重要的特殊图：欧拉图和汉密尔顿图，各表示能够找到欧拉环路与汉密尔顿环路的图。 欧拉环路是由七桥问题来的：如何走过7座桥回到起点。在一般的图中，该问题可以被表示为：能不能找到 一条经过所有边，最后回到源点的环路。
 欧拉路径是比欧拉环路更广的概念。欧拉路径即图中经过所有边一次的简单路径，不要求终点和源点为 同一点。汉密尔顿路径与之类似，只是要求的不是经过所有边一次而是经过所有点一次。汉密尔顿环路 即起点与终点在同一点的汉密尔顿路径，汉密尔顿图即能找出汉密尔顿路径的图。
 对于欧拉图的判定最早由欧拉提出。方法很简单：图中每个点的度必须为偶数。判断欧拉路径的方法是 除了两个点外每个点的度数都为偶数，那两个点的度都为奇数。我们可以想象边经过一点的过程，如果 想要经过每条边一次，那每次入射一点后必定需要从另一条新的边出去。就像在一根线上串珠子的过程。 对于欧拉路径，除了头和尾两个点的度为奇数，其他都是偶数。对于欧拉环路来说头和尾是同一点， 从该点射出的路径最终还是要通过另一边回到该点。因此欧拉图所有点的度数都为偶数。
 和欧拉图不同，汉密尔顿图没有已知的多项式时间判定方法。事实上，汉密尔顿图的判定是NP完全问题。 虽然没有找到判断汉密尔顿图的充要条件，但是已知的有充分条件。n&amp;gt;=3个节点的简单图上，任意一对非 邻接节点的度数和&amp;gt;=n.或者，任意节点的度&amp;gt;=n/2.</description>
    </item>
    
    <item>
      <title>电脑是怎么启动的</title>
      <link>https://iluvata.github.io/post/2021-03-01_how-computer-startup/</link>
      <pubDate>Mon, 01 Mar 2021 22:52:59 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-03-01_how-computer-startup/</guid>
      <description>x86启动过程简介  x86计算机开机过程大致可以被分为几个阶段：
  按下开机键
  CPU跳转至BIOS物理地址
  BIOS进行开机自检
  寻找启动设备
  从MBR加载启动区
  BIOS转移控制给BootLoader
  第一阶段：硬件  BIOS  Basic Input/Output System 基本输入输出系统，被固化在ROM上的一组程序，提供最底层对硬件的控制。 也被称为固件。
UEFI  Unified Extensible Firmware Interface 统一可拓展固件接口。堆栈传参，动态链接，更大寻址。
    MBR  Master Boot Record 主引导记录。硬盘的第一个扇区，存放预启动信息、分区表信息。
    第二阶段：系统软件  Boot Loader  操作系统内核加载器。初始化硬件，建立内存空间映射。
  GRUB
  LILO
    加载内核  根据grub设定的内核映像所在路径读取，解压，放入内存。初始化函数，设备，建立Linux核心环境（初始化寄存器、堆栈）。</description>
    </item>
    
    <item>
      <title>理解贪心算法与Dijkstra算法</title>
      <link>https://iluvata.github.io/post/2021-02-24_greedy-and-dijkstra/</link>
      <pubDate>Wed, 24 Feb 2021 10:52:06 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-02-24_greedy-and-dijkstra/</guid>
      <description>贪心与动态规划  我们知道动态规划求解的问题需要具有   最优子结构   重复子问题   具有最优子结构的问题有时也可以用贪心算法求解。条件是最优解中只包含一个子问题的最优解，而一般的动态规划 最优解包含多个子问题的最优解。比如fib算法，fib(5)需要fib(4)与fib(3)两个子问题的解，无法使用贪心算法。 阶乘算法factorial(5)的递归解只需要使用一个子问题factorial(4)的解，这种情况使用贪心算法，即无需自底向上 记录每一子问题的解，只需记录当前最近一子问题的解用于求解当前解。
 一个更直观的例子是0-1背包问题和部分背包问题。背包问题要求在指定的一些商品中选出能装入背包重量的最大价值的商品 组合。0-1背包问题中的每个商品是一个整体，要么整个装入，要么不装。部分背包问题里的商品类似水或金沙，可以分割后 装入部分。0-1背包问题是典型的动态规划例子，而部分背包则可以用贪心。
 我们容易得到背包问题的最优子结构：要求重量的最优解包含了背包去掉某个物品重量后的最优解。考虑所有物品的最优解中 包含了考虑其中部分物品得到的最优解。对于0-1背包问题，通过以上两个维度我们可以列出状态转移方程：从考虑0个物品开始 依次加入每个物品，重量从0开始递增至所给背包重量；当前重量下考虑了当前加入所有物品能得到的最大价值 = max{(当前最大重量减去 当前物品重量后，不考虑当前物品能得到的最大价值 + 当前物品价值), (同等重量，不考虑当前物品能得到的最大价值),( 考虑了当前物品，最大重量-1时能得到的最大价值)}. 对于部分背包问题，如果还是使用0-1背包的方法来求解，我们会发现这次 要求的重量都是连续的，每次递增的重量无法确定。但是不妨假设我们可以每次递增无穷小的重量，就容易看出每次状态转移时， 能得到最大价值的选择一定是从剩余物品中（价值/重量）比例最大的物品中抽取加入。这样每次求最优解用到的唯一一个最优 子问题就能被确定下来，我们可以直接使用贪心算法，即，永远在剩余物品中选择（价值/重量）比例最大的物品加入，直到包 满。
 另一个例子是活动选择问题。对几个互相竞争的活动进行调度，希望找出一个最大的相互兼容活动集合。给出每个活动的开始时间与持续时长， 我们希望得到一定时间段内所能容纳的最多活动数量（多个活动间不能有重叠时间）。容易找到这个问题的最优子结构：每个活动将整体时间分为 两部分：该活动前的时间与该活动后的时间。在这两段时间内我们都需要最大化执行任务数，两段的任务数之和+1，所得的就是整个时间段的最优 解。找到最优子结构后就不难得到动态规划算法了。我们知道在这个问题的最优解中包含了两个子问题的最优解，即：活动左边时间段最优解与右边时间段 最优解。如果我们进一步观察，可以发现如果我们将选择的当前活动限制为当前时间段后开始并能最早执行完的活动，得到当前最优解所需的子问题 就只剩一个：当前活动后的时间段。可以证明该贪心选择能够得到最优解。通过一个简单的变换，我们将原来需要2个子问题的解变成了只需要1个子问题的解。 这种情况下，我们无需记录所有子问题的解来进行动态规划自底向上求解当前解，只需要记录前一子问题的解，自顶向下求解问题。
 一些能够轻易看出使用动态规划求解的问题，可以思考能不能通过变换求解过程得到贪心策略来进一步优化，给出贪心算法。
  贪心策略的基本内容  使用贪心算法需要的条件有两个：
  贪心选择性质
  最优子结构
  贪心选择性质即上文中我们说的“能找到只包含一个子问题的最优解“。通过适当的变换，一些问题可以找到贪心选择性质，如上文中的活动调度问题。 最优子结构即动态规划中的“由子问题的最优解构成当前问题最优解”的性质。满足这两个条件的问题即可使用贪心算法。但在有些情况下，不能轻易找出 最优子结构，但是问题的确可以使用贪心算法求解。比如PAT-1067.
  Dijkstra算法与Bellman-Ford算法  Dijkstra算法  作为图论中几乎是最有名的算法，Dijkstra算法解决了最短路径问题。从算法思想的角度来说，Dijkstra算法使用了贪心策略。与之相对的是 Bellman-Ford算法。同为计算最短路径的算法，Bellman-Ford算法使用了动态规划的思想，复杂度为O(n^3)。Dijkstra算法在此基础上 进一步限定条件（Bellman-Ford算法可以用来计算带有负权的图，Dijkstra只能用于权值为正数的情况）利用了问题具有贪心选择性质，用贪心策略 将最短路径算法的复杂度进一步减到了O(n^2).</description>
    </item>
    
    <item>
      <title>在org mode中嵌入latex</title>
      <link>https://iluvata.github.io/post/2021-02-22_latex-with-emacs/</link>
      <pubDate>Mon, 22 Feb 2021 23:30:15 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-02-22_latex-with-emacs/</guid>
      <description>最近写博客发现就算在想着办法避免使用数学公式，在写有关算法，更不用说数学博客的时候还是不可避免的会碰上好多需要使用latex的情况。 于是干脆在这里记一下怎么在org mode中内嵌latex。
\begin{equation} % arbitrary environments, x=\sqrt{b} % even tables, figures \end{equation} % etc
 If $a^2=b$ and \( b=2 \), then the solution must be either $$ a=+\sqrt{2} $$ or \[ a=-\sqrt{2} \].
 但是虽然orgmode支持的latex能导出pdf，hugo生成的html网页还是不支持。
 参考链接：官方文档 Spacemacs和Org-mode和LaTeX Hugo中的LaTeX渲染 Hugo中添加LaTeX渲染</description>
    </item>
    
    <item>
      <title>理解动态规划与warshall算法</title>
      <link>https://iluvata.github.io/post/2021-02-19_dp-and-warshall/</link>
      <pubDate>Fri, 19 Feb 2021 13:35:34 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-02-19_dp-and-warshall/</guid>
      <description>今天刚好在离散里学了用来计算传递闭包的warshall算法，就在这里把离散里计算闭包的算法 和动态规划一起整理一下。
集合、关系和闭包  要理解闭包首先需要了解集合和关系（函数）。 在离散数学中我们讨论的集合都是非公理化的朴素集合论（会导致罗素悖论）。有时间可以了解下公理集合论。
关系与函数  关系： 关系是一个集合中的元素到另一个集合中元素的映射方式。二元关系是两个集合笛卡尔积的子集。 关系能够具有的性质包括自反性，对称性，传递性，反自反性，反对称性。具有自反、堆成、传递性 的关系称为等价关系。其他的特殊关系有偏序（包含全序、良序、字典序）
 函数：函数可以看作一种特殊的关系。 函数是每个定义域中元素到唯一一个值域中元素的映射.
 A function from A to B is an assignment of exactly one element of B to each element of A.
 函数的种类包括
  单射 一一对应(one-to-one)函数：如果定义域中的两个元素不相等，那值域中对应的两个元素也肯定不相等.
  满射（onto）函数：值域中每个值都有对应的定义域元素.
  双射： 满足单射及满射
    闭包  闭包：一个集合具有某个性质的最小超集。例如在一个集合S上关系R的自反闭包是R并S0, S0是集合S中所有元素到自身关系的集合。 其他常用的闭包还有对称闭包和传递闭包。自反闭包记作r(R),对称闭包s(R),传递闭包t(R).
 一个关系的自反闭包与对称闭包计算都很简单，传递闭包要麻烦些。一个具有传递性的关系是指在该关系中， 如果出现了(a,b)和(b,c)，则(a,c)也存在。想得到一个关系具有传递性的最小超集，我们要检查当前该关系中所有满足(a,b) (b,c) 的pair，得到(a,c)后加入。但是只进行一次后不一定能得到我们想要的传递性关系。比如原先关系R为{(a,b), (b,c), (c,d)}, 进行一次计算后得到的R1是{(a,b), (b,c), (c,d), (a,c), (b,d)}。R1中存在(a,b)和(b,d)，但是没有(a,d)，并不是我们想要的 自反闭包。我们需要再做一次相同的步骤。在一个无穷关系中，相同的步骤需要执行无穷次。这就是计算传递闭包的算法。</description>
    </item>
    
    <item>
      <title>nextcloud网盘搭建</title>
      <link>https://iluvata.github.io/post/2021-02-19_deploy-nextcloud/</link>
      <pubDate>Fri, 19 Feb 2021 11:45:28 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-02-19_deploy-nextcloud/</guid>
      <description>最近发现在多个设备，系统之间换来换去，文件传输是个问题。想到还有个空闲着的服务器， 为什么不搭个nextcloud网盘，这样在各个系统做笔记和传文件都方便。
 其实我之前在服务器上用过nextcloud，但不知道什么原因好像挂了。。那今天就重新来部署一次吧。
 在网上找到一篇简易的搭建教程,搭建宝塔面板建站，下载nextcloud安装器（php文件，放在网站上浏览器直接访问）， 跟着步骤就安装完成了。。 https://zhuanlan.zhihu.com/p/38485411</description>
    </item>
    
    <item>
      <title>2020年度回顾以及新年目标</title>
      <link>https://iluvata.github.io/post/2021-02-16_yearly-review/</link>
      <pubDate>Tue, 16 Feb 2021 19:00:39 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-02-16_yearly-review/</guid>
      <description>2020简要回顾  今天是农历大年初五，是个对过去一年进行复盘与新的一年进行规划的好时机。我的过去一年如果用两个词来总结的话应该就是疫情和考研了。由于疫情，前半年我是在家里度过的；后半年到了学校后也是一直在准备考研。
 年初（可能年前就开始了）的时候，由于在家无聊，我开始疯狂追番，然后好像一直看到5月。。。我能记得的那几个月看的番有：碧蓝之海，clannad，青春猪头少年，实教，春物，冰菓，日在校园，笨蛋测验召唤兽，月色真美， 魔法少女小圆，白色相簿2，四谎，k-on 等等。3月开始上网课，4月甚至逃了2周的课从早到晚看小说追完了春物，还在网上买了大老师最喜欢的max咖啡（不得不说还算不错，特别是在5月锻炼完洗了澡后来一罐冰冰的max的感觉贼舒爽）。。
 然后正式开始准备考研应该是在5月中旬，开始的一个月还在看k-on，每天瞎看几个小时数学，然后看几个小时动漫。。
  3月之前还有在一边查考研院校信息一边准备PAT，基本上甲级的题库快刷完了。但最后开学的时间一直在推就把报名退了。代码放在这个仓库。考研一开始选了4个学校：上海科技大学，川大，北航，浙大。最后确定了北航。
 2-3月还开始了英语背单词，于是年后那一两个月的生活就是早上11-12点起床，中午吃了午饭后背背百词斩，下午做个4-5道pat，晚饭后开始看动漫到两三点。 从5月期中考那段时间开始，感觉回校应该无望了，就买了考研书开始准备起来。之后具体的安排写在考研初试里面。8月回校，每天抽点时间准备了大三下的期末考。接着9月学校安排了实训。10月开始可以一心备考，到12月底考完。
 考完后马上在牛客网上投了几份实习简历，回家。十几份简历只有一份网易北京测开的给了面试，然后拿到offer在1月中到北京开始实习。实习到现在也有一个月了，考完初试快2个月了，离复试差不多剩1个月。这期间一边玩一边随便看点 复试有关的东西。是时候开始全力准备复试了。
  考研初试  3-5月  从3月开始就一直在查院校信息。这时每天中午用百词斩背单词，悠哉游哉的看动漫，开始上网课后 也会登上去听。考北航一部分原因是之前12月的CSP考了320分，看有哪些院校考研可以用上的时候 看到了北航。对于CSP考试我感觉考个300分一点也不难，之前完全没准备过，上场后不要慌，第3题 慢慢写能写出来。前3题拿满后再看下后两题能不能骗点分。要强行说我为这个考试做了什么准备的话 可能只有大二下学期的时候（还是大三上？我有点忘了。。。）照着一个知识点清单把算法导论中的 重点章节啃完了。。。还有就是可能刷了一点leetcode题。那时候还没开始刷PAT，但事实证明刷了 PAT之后去考CSP也没多大帮助，前三题基本用不到什么算法，细心点慢慢写，不要急就能做出来。。
 4月买了恋恋有词开始背。每天早上一个list，按照记忆曲线复习。我在第一遍背的时候先用emacs把 不熟的单词整理出来，之后重复背的时候就直接在emacs上背。
  还可以直接在上面直接做时间规划，每次调出agenda页面后直接就可以跳转到当天要背的列表。
  自己整理的好处除了能够量身定制词汇表外，遇到自己容易混淆的几个单词也能整理在一起，通过 链接跳转。还有就是emacs全键盘操作，效率很高。
 恋恋有词总共就30个list，到5月就背完了。背完了后除了继续复习一轮中按照记忆曲线没结束的 列表，每天靠午休的时候摸鱼看英文小说新增单词。4月到5月中一个半月时间居然看完了福尔摩斯 里血字的研究和一半的四签名。。在用emacs背恋恋有词期间（直到考完），手机上用app背单词 也没停。不过背单词的软件倒是换了几个，从3月前的百词斩换成默默，之后变成扇贝，可以说每个 软件上都快背完一本书但就是没背完。。。
 这3个月基本每天只花了一点时间在考研英语上，不知不觉时间就混过去了。后面买了李正元全书， 花2周囫囵吞枣看了一遍但感觉完全没用。。。
  6-7月  5月中旬开始我每天规定了7个小时的学习时间，算是正式开始准备考研了。因为在家里容易偷懒， 我用上了之前买的滴答清单会员来制定每天的学习计划。
  滴答清单里面可以记录习惯打卡，我每天上午做3小时的数学，下午3小时的专业课，晚上2小时数学 习题。每次点击可以记录半小时。滴答清单有个番茄时钟的功能（需要会员），我就按照番茄计时 每次学25分钟，完成后点一下习惯记录算学了半小时，休息5分钟。但其实一般很少25分钟准时休息， 都是完成了计时结束时正在做的那道题或学的那个知识点后再休息，所经常会超时，平均算学了半小时 也不算过分吧2333. 一开始在休息的时候还经常会拿起 手机来玩，很快发现5分钟休息玩手机根本不能起到休息的作用，而且一不注意就容易忽略计时器 提醒继续玩下去。后来感觉最好的休息方式还是啥都不干，坐着冥想哈哈。 一开始买了滴答会员后我还加了个习惯：每天冥想10分钟，没想到坚持了半年直到开学，成了我 坚持最久完成率最高的习惯。。训练放空思想可能对专注确实起到了一些作用吧。
 当时我还在自己的阿里云服务器上搭了个nextcloud网盘，把每天用emacs记录的单词直接放在上面。 除此之外，每天晚上还会总结一下当天学的东西，在orgmode里写下来放上去。这时我是每周周日 休息一天，在休息日会看着上周每天总结的东西再做一个周总结。我把放总结笔记的文件夹叫做 watson，就像想把学过的东西教给他一样去总结哈哈。</description>
    </item>
    
    <item>
      <title>在spacemacs中写scheme</title>
      <link>https://iluvata.github.io/post/2021-02-02_scheme-in-emacs/</link>
      <pubDate>Tue, 02 Feb 2021 22:35:46 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-02-02_scheme-in-emacs/</guid>
      <description>参考资料：官方文档 在spacemacs安装scheme环境 在emacs里学习SICP geiser文档
windows安装  一开始看官方文档和 在spacemacs安装scheme环境 做了好久，试图在windows上搭起环境，但是中间遇到好多问题，这里记下几个。。
 首先是 chicken 的安装。文档只说了apt包，但其实pip包也可以？（没试过）。我用的是windows的chocolatey，成功安装了。
 在安装了 chicken 后，为了完整安装对应文档（不知道为什么不能把文档放到同个包里一起安装了。。。），还要运行一下命令：
$ chicken-install -s apropos chicken-doc $ cd `csi -p &amp;#39;(chicken-home)&amp;#39;` $ curl https://3e8.org/pub/chicken-doc/chicken-doc-repo.tgz | sudo tar zx  在尝试用powershell运行第一条指令时提示不存在cp指令中断了。查了好久资料后发现可以用git shell运行成功。
 然后第二条指令其实是运行 csi chicken scheme 解释器后运行 &amp;#39;(chicken-home)&amp;#39; ，结果作为输出，进入chicken安装目录。
 我在安装chicken包时看到安装目录在 c:/tools/chicken 下，就直接转过去了（不知道为什么，解释器中这条命令也运行失败。。）
 最后是在当前目录下载chicken-doc并且解tar包。但我是在windows下，就手动用浏览器访问https://3e8.org/pub/chicken-doc/ 发现有zip包，下载下来解压后放到 c:/tools/chicken 下，这步也算完成了。
 接着按照第二个博客中的步骤，确实可以运行了，但看不到输出也不会报错，重启后甚至又不能运行了。。。
 太折磨人了，明天试下转到linux用第三个博客中的步骤。
  linux安装配置  在 dotspacemacs-configuration-layers 中添加scheme, 在终端安装 mit-scheme 。emacs打开scm文件后 M-x run-geiser ，回到scm文件窗口 C-c C-s 选择mit.</description>
    </item>
    
    <item>
      <title>用easy-hugo在spacemacs中写hugo博客</title>
      <link>https://iluvata.github.io/post/2021-02-02_hugo-with-emacs/</link>
      <pubDate>Tue, 02 Feb 2021 21:52:48 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-02-02_hugo-with-emacs/</guid>
      <description>配置easy-hugo layer  我在github上找到有人写了spacemacs的easy-hugo layer，可以直接用，地址在这里. 把这个仓库中的 packages.el 放到自己的 .emacs.d/private/hugo 文件夹下就可以了. 然后在 .spacemacs 文件中的 dotspacemacs-configuration-layers 中添加 hugo 层.  这时候如果直接运行 M-x easy-hugo 会提示找不到 easy-hugo-basedir ，在.spacemacs 文件夹下的 user-config 项中加上 (setq easy-hugo-basedir &amp;#34;your-path-to-hugo-basedir&amp;#34;) 重新载入就可以运行了。   运行指南  在输入 M-x easy-hugo 进入easy-hugo mode 后，这个layer已经帮我们重新绑定了几个快捷键    Key Binding Description     SPC m n &amp;#39;easy-hugo-newpost   SPC m D &amp;#39;easy-hugo-article   SPC m p &amp;#39;easy-hugo-preview   SPC m P &amp;#39;easy-hugo-publish   SPC m o &amp;#39;easy-hugo-open   SPC m d &amp;#39;easy-hugo-delete~   SPC m c &amp;#39;easy-hugo-open-config   SPC m f &amp;#39;easy-hugo-open   SPC m N &amp;#39;easy-hugo-no-help   SPC m v &amp;#39;easy-hugo-view   SPC m r &amp;#39;easy-hugo-refresh   SPC m s &amp;#39;easy-hugo-sort-time   SPC m S &amp;#39;easy-hugo-sort-char   SPC m G &amp;#39;easy-hugo-github-deploy   SPC m A &amp;#39;easy-hugo-amazon-s3-deploy   SPC m C &amp;#39;easy-hugo-google-cloud-storage-deploy   SPC m q &amp;#39;evil-delete-buffer     如果记不住，按下 SPC 后就会有提示  比如 SPC m n 创建新文章</description>
    </item>
    
    <item>
      <title>hugo 博客配置</title>
      <link>https://iluvata.github.io/post/2021-01-27_hugo-config/</link>
      <pubDate>Wed, 27 Jan 2021 10:58:42 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-01-27_hugo-config/</guid>
      <description> 主题配置  我创建了一个包含整个博客目录的仓库，在这里，以便在不同的地方随时pull下来
 需要注意的是这个仓库中还嵌套包含了另外两个仓库，页面仓库对应public文件夹，以及 dream主题仓库，对应themes/dream文件夹
  02-19注：之前以为删了dream里面的.git就可以直接管理整个博客了，后面发现并不行。需要用 git rm --cached themes/dream 把git子模块去掉
  主题内容配置文件为config.toml，其中配置的路径都是从themes/dream/static文件夹开始的相对路径.
 如配置头像所用的avatar=&amp;#34;/img/avatar.png&amp;#34;实际所在位置为themes/dream/static/img/avatar.png
 修改封面图片：文章添加参数&amp;#34;cover&amp;#34; cover:/img/somepicture.png
 添加tag和category: 在文章头部添加参数tags: [&amp;#34;tag1&amp;#34;, &amp;#34;tag2&amp;#34;]，categories: [&amp;#34;category1&amp;#34;, &amp;#34;category2&amp;#34;]
   插入附件  文章嵌入代码：用#+begin_src和#+end_src表示代码
print(&amp;#34;hello world&amp;#34;)   插入图片：用
[[图片路径]]     </description>
    </item>
    
    <item>
      <title>hugo博客站点搭建</title>
      <link>https://iluvata.github.io/post/2021-01-08_hugo/</link>
      <pubDate>Fri, 08 Jan 2021 15:02:22 +0800</pubDate>
      
      <guid>https://iluvata.github.io/post/2021-01-08_hugo/</guid>
      <description>  由于支持emacs org-mode（顺便还能在github上部署），我选择了hugo进行建站。
安装hugo  sudo apt-get install hugo    新建站点  hugo new site /path/to/site  下载主题（我用的是dream） 本地运行
hugo server --buildDrafts -t dream  新建github仓库 云端部署
hugo --theme=dream --baseUrl=&amp;#34;https://iluvata.github.io/&amp;#34; --buildDrafts    写/发布文章  hugo new post/newBlog.org hugo --theme=dream --baseUrl=&amp;#34;https://iluvata.github.io/&amp;#34; --buildDrafts  文章路径为：根目录/content/post/newBlog.org  云端仓库为：根目录/public （在此目录下管理git）  云端文章目录为：根目录/public/post/blog   </description>
    </item>
    
  </channel>
</rss>
